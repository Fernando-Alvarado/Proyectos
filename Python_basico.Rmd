---
title: "Python_basico"
author: "Fernando Alvarado"
date: "2025-04-11"
output: html_document
---

# Resumen introduccion a Python basico 


## üß± 1. Sintaxis b√°sica


En Python, **la estructura del c√≥digo depende de la indentaci√≥n**. No se usan llaves `{}` ni `begin-end`, como en otros lenguajes. En su lugar, **los bloques de c√≥digo se delimitan por sangr√≠a** (indentaci√≥n).

**La indentaci√≥n est√°ndar** es de 4 espacios (o un tab, pero se recomienda espacios para evitar errores).

Adem√°s, Python **usa dos puntos `:`** al final de l√≠neas que inician bloques (como `if`, `for`, `while`, `def`, etc.).

```{python}
# Ejemplo de indentaci√≥n y uso de dos puntos
x = 5

if x > 0:
    print("x es positivo")
    print("Esto tambi√©n est√° dentro del if")

print("Esto ya est√° fuera del if")
```

## üß± 2. Tipos de datos en Python

En Python, cada valor tiene un **tipo de dato**, que define qu√© operaciones se pueden hacer con √©l. A continuaci√≥n revisamos los tres tipos m√°s comunes:

---

### üî¢ N√∫meros

Python maneja varios tipos num√©ricos, pero los principales son:

- `int`: n√∫meros enteros (sin decimales)
- `float`: n√∫meros con decimales

```{python}
# Entero
edad = 25
print(type(edad))  # <class 'int'>

# Flotante
peso = 70.5
print(type(peso))  # <class 'float'>
```

Puedes hacer operaciones matem√°ticas b√°sicas con ellos:

```{python}
a = 10
b = 3

print(a + b)  # Suma
print(a - b)  # Resta
print(a * b)  # Multiplicaci√≥n
print(a / b)  # Divisi√≥n (resultado float)
print(a // b) # Divisi√≥n entera
print(a % b)  # M√≥dulo
print(a ** b) # Potencia
```

---

### üßµ Cadenas de texto (`str`)

Se escriben entre comillas simples `'texto'` o dobles `"texto"`.

```{python}
nombre = "Ana"
mensaje = 'Hola mundo'
print(type(nombre))  # <class 'str'>
```

Puedes concatenar o repetir cadenas:

```{python}
saludo = "Hola"
nombre = "Luis"
print(saludo + " " + nombre)  # Concatenaci√≥n
print("¬°" + saludo + "! " * 3)  # Repetici√≥n
```

Tambi√©n puedes acceder a sus caracteres:

```{python}
palabra = "Python"
print(palabra[0])  # P
print(palabra[-1]) # n
print(palabra[1:3])  # yt
```

---

### ‚úÖ Booleanos (`bool`)

Solo tienen dos valores posibles: `True` o `False`.

```{python}
# Resultado de una comparaci√≥n
mayor = 5 > 3
print(mayor)         # True
print(type(mayor))   # <class 'bool'>
```

Los booleanos son usados en condicionales, bucles, y operaciones l√≥gicas (`and`, `or`, `not`).

```{python}
a = True
b = False

print(a and b)  # False
print(a or b)   # True
print(not a)    # False
```

## üß± 3. Variables en Python

En Python, una **variable** es un nombre que se asigna a un valor para poder usarlo m√°s adelante. No necesitas declarar el tipo de la variable; Python lo deduce autom√°ticamente.

---

### üìù Declaraci√≥n y asignaci√≥n

Para **crear una variable**, simplemente se usa el signo igual `=` para asignarle un valor:

```{python}
x = 5
nombre = "Ana"
pi = 3.1416
```

- `x` es una variable de tipo entero (`int`)
- `nombre` es una cadena de texto (`str`)
- `pi` es un n√∫mero flotante (`float`)

Puedes usar estas variables en operaciones o imprimirlas:

```{python}
area = pi * (5 ** 2)
print("√Årea del c√≠rculo:", area)
```

## üß± 4. Operadores en Python

### ‚öñÔ∏è Operadores de comparaci√≥n

Se usan para comparar dos valores. El resultado siempre es `True` o `False`.

| Operador | Descripci√≥n           | Ejemplo      |
|----------|-----------------------|--------------|
| `==`     | Igual a               | `5 == 5`     |
| `!=`     | Distinto de           | `5 != 3`     |
| `<`      | Menor que             | `3 < 7`      |
| `>`      | Mayor que             | `10 > 2`     |
| `<=`     | Menor o igual que     | `5 <= 5`     |
| `>=`     | Mayor o igual que     | `6 >= 4`     |

```{python}
x = 10
y = 5

print(x == y)
print(x != y)
print(x > y)
print(x < y)
print(x >= y)
print(x <= y)
```

---

### üîÄ Operadores l√≥gicos

Se usan para combinar condiciones.

| Operador | Descripci√≥n         | Ejemplo              | Resultado |
|----------|---------------------|-----------------------|-----------|
| `and`    | Verdadero si ambos son verdaderos | `True and False` | `False`   |
| `or`     | Verdadero si al menos uno lo es   | `True or False`  | `True`    |
| `not`    | Niega un valor l√≥gico             | `not True`       | `False`   |

```{python}
a = True
b = False

print(a and b)
print(a or b)
print(not a)
```



## üß± 5. Estructuras de control en Python

Las estructuras de control nos permiten **tomar decisiones** y **repetir instrucciones** en nuestro c√≥digo. Son la base de cualquier programa din√°mico.

---

### üîÄ Condicionales: `if`, `elif`, `else`

Sirven para ejecutar diferentes bloques de c√≥digo seg√∫n condiciones l√≥gicas.

```{python}
edad = 18

if edad >= 18:
    print("Eres mayor de edad")
elif edad >= 13:
    print("Eres adolescente")
else:
    print("Eres menor de edad")
```

- Se usa `:` para abrir el bloque
- El c√≥digo dentro debe ir **indentado**
- Puedes tener tantos `elif` como necesites

---

### üîÅ Bucles: `for` y `while`

#### üî∏ `for`

Se usa para recorrer secuencias como listas, rangos o cadenas:

```{python}
for i in range(5):
    print("N√∫mero:", i)
```

```{python}
frutas = ["manzana", "pl√°tano", "uva"]
for fruta in frutas:
    print(fruta)
```

#### üî∏ `while`

Se repite mientras una condici√≥n sea verdadera:

```{python}
x = 0
while x < 3:
    print("x vale:", x)
    x += 1
```

‚ö†Ô∏è Aseg√∫rate de que la condici√≥n cambie, si no, se repite infinitamente.

---

### ‚èπÔ∏è Control de flujo: `break` y `continue`

#### `break`: termina el bucle antes de tiempo

```{python}
for i in range(10):
    if i == 5:
        break
    print(i)  # Imprime del 0 al 4
```

#### `continue`: salta a la siguiente iteraci√≥n

```{python}
for i in range(5):
    if i == 2:
        continue
    print(i)  # Imprime 0, 1, 3, 4 (salta el 2)
```




## üß± 6. Funciones en Python

Las funciones nos permiten **organizar, reutilizar y simplificar c√≥digo**. Son bloques que ejecutan tareas espec√≠ficas y pueden recibir datos (argumentos) y devolver resultados (valores de retorno).

---

### üîß Definir funciones con `def`

Se definen usando la palabra clave `def`, seguida del nombre de la funci√≥n, par√©ntesis y dos puntos `:`.

```{python}
def saludar():
    print("¬°Hola desde una funci√≥n!")
    
saludar()
```

Puedes poner el c√≥digo que quieras dentro de una funci√≥n, siempre **indentado**.

---

### üì• Argumentos y valores de retorno

Las funciones pueden recibir **argumentos** (entradas) y devolver un **valor** con `return`.

```{python}
def sumar(a, b):
    resultado = a + b
    return resultado

suma = sumar(3, 4)
print(suma)
```

Tambi√©n puedes definir argumentos con **valores por defecto**:

```{python}
def saludar(nombre="usuario"):
    print(f"Hola, {nombre}")

saludar()
saludar("Ana")
```

---

### ‚öôÔ∏è Funciones incorporadas (built-in)

Python trae muchas funciones listas para usar:

| Funci√≥n      | Descripci√≥n                     |
|--------------|---------------------------------|
| `print()`    | Imprime en pantalla             |
| `len()`      | Devuelve la longitud de una secuencia |
| `type()`     | Muestra el tipo de un valor     |
| `int()`, `str()`, `float()` | Conversiones de tipo |
| `input()`    | Lee entrada del usuario         |
| `max()`, `min()` | Valores m√°ximos y m√≠nimos  |
| `sum()`      | Suma los elementos de una lista |

```{python}
frutas = ["manzana", "pera", "uva"]

print(len(frutas))       # 3
print(type(frutas))      # <class 'list'>
print(max([2, 5, 1]))    # 5
print(sum([1, 2, 3]))    # 6
```




## üß± 7. Estructuras de datos en Python

Python incluye varias estructuras para almacenar colecciones de datos. Cada una tiene propiedades particulares seg√∫n lo que necesites hacer con la informaci√≥n.

---

### üîπ Listas (`[]`)

Son **colecciones ordenadas y modificables**. Pueden contener diferentes tipos de datos.

```{python}
numeros = [1, 2, 3, 4, 5]
print(numeros[0])       # Primer elemento
print(len(numeros))     # Longitud de la lista

numeros.append(6)       # Agrega un elemento
numeros[2] = 33         # Modifica un elemento
print(numeros)
```

---

### üî∏ Tuplas (`()`)

Son como las listas, pero **inmutables** (no se pueden modificar despu√©s de crearse).

```{python}
coordenadas = (10, 20)
print(coordenadas[0])    # 10

# coordenadas[1] = 30    ‚ùå Error: no se puede modificar
```

Se usan cuando quieres proteger los datos contra cambios accidentales.

---

### üîë Diccionarios (`{}`)

Guardan pares **clave:valor**, como una mini base de datos.

```{python}
persona = {
    "nombre": "Carlos",
    "edad": 30,
    "ciudad": "Madrid"
}

print(persona["nombre"])
persona["edad"] = 31        # Modificar un valor
persona["email"] = "carlos@example.com"  # Agregar nueva clave
print(persona)
```

---

### üîò Conjuntos (`set()`)

Son **colecciones desordenadas y sin elementos repetidos**.

```{python}
numeros = {1, 2, 3, 2, 1}
print(numeros)  # {1, 2, 3}

# Operaciones de conjuntos
pares = {2, 4, 6}
print(numeros & pares)   # Intersecci√≥n: {2}
print(numeros | pares)   # Uni√≥n: {1, 2, 3, 4, 6}
```
### üßÆ Matrices (`numpy.array`)

Python no tiene una clase nativa para matrices como R, pero se pueden usar arrays bidimensionales con `numpy`.

```{python}
import numpy as np

matriz = np.array([[1, 2, 3],
                   [4, 5, 6]])
print(matriz)
print(matriz.shape)     # Dimensiones
print(matriz[1, 2])     # Elemento fila 2, columna 3
```

---

### üìä DataFrames (`pandas.DataFrame`)

Equivalentes a los **dataframes de R**, permiten almacenar datos tabulares.

```{python}
import pandas as pd

data = {
    "Nombre": ["Ana", "Luis", "Marta"],
    "Edad": [23, 35, 29],
    "Ciudad": ["CDMX", "Monterrey", "Guadalajara"]
}

df = pd.DataFrame(data)
print(df)

print(df["Edad"])       # Acceder a una columna
print(df.iloc[0])       # Acceder a la primera fila
print(df.shape)         # Dimensiones
```




## üß± 8. Manejo de errores en Python

Cuando un programa encuentra un problema durante su ejecuci√≥n, Python lanza un **error (excepci√≥n)**. Si no lo controlamos, el programa se detiene. Para evitarlo, usamos bloques `try`, `except` y `finally`.

---

### ‚ö†Ô∏è Estructura b√°sica: `try` y `except`

```{python}
try:
    # C√≥digo que podr√≠a fallar
    x = 10 / 0
except ZeroDivisionError:
    print("¬°No se puede dividir entre cero!")
```

- El bloque `try` contiene el c√≥digo que puede lanzar un error.
- El bloque `except` **captura el error** y permite continuar el programa.

---

### üîé Capturar errores gen√©ricos

```{python}
try:
    a = int("texto")
except Exception as e:
    print("Ocurri√≥ un error:", e)
```

Usar `Exception` permite capturar cualquier tipo de error, y `as e` guarda el mensaje.

---

### üîÑ Bloque `finally`

Se ejecuta **siempre**, ocurra o no un error. Ideal para cerrar archivos, liberar memoria, etc.

```{python}
try:
    x = 1 / 0
except ZeroDivisionError:
    print("Error de divisi√≥n")
finally:
    print("Este bloque siempre se ejecuta")
```

---

### ‚úÖ Buenas pr√°cticas

- Espec√≠fica el tipo de error si sabes cu√°l puede ocurrir (`ValueError`, `ZeroDivisionError`, etc.)
- Usa `finally` si hay tareas que siempre deben ejecutarse.
- No uses `except:` sin m√°s ‚Äî puede ocultar errores importantes.

---

## üìå Ap√©ndice: Tips sobre manejo de errores

### ‚ùì ¬øPuedo usar m√∫ltiples `except`?

‚úÖ S√≠. Puedes capturar distintos errores por separado:

```{python}
try:
    x = int("hola")  # Esto causar√° ValueError
except ValueError:
    print("No es un n√∫mero v√°lido")
except ZeroDivisionError:
    print("Divisi√≥n entre cero no permitida")
```

Esto permite ofrecer mensajes **espec√≠ficos seg√∫n el tipo de error**.

---

### ‚ùì ¬øCu√°ndo es recomendable usar `try`/`except`?

- Cuando el error **no es fatal** y el programa puede continuar.
- Si dependes de:
  - Entrada del usuario
  - Archivos
  - Red o APIs externas
- Si deseas capturar el error para **mostrar un mensaje claro** o **registrarlo**.

‚ö†Ô∏è No abuses de `try/except` para evitar validar datos. Primero intenta anticipar los errores.

---

### ‚ùì ¬øPuedo hacer algo m√°s que imprimir errores?

¬°S√≠! Dentro de un bloque `except` puedes:

- Escribir el error en un archivo `.txt`
- Mostrar mensajes en una interfaz gr√°fica
- Volver a solicitar datos al usuario
- Lanzar otra excepci√≥n
- Notificar a otro sistema (por ejemplo, v√≠a correo)

```{python}
try:
    resultado = 10 / 0
except ZeroDivisionError as e:
    with open("errores.txt", "a") as f:
        f.write(f"Ocurri√≥ un error: {e}\n")
    print("Error registrado correctamente.")
```


---

## üìå Ap√©ndice: Errores comunes en Python

En esta secci√≥n listamos errores frecuentes en distintos contextos de trabajo con Python, sus causas y c√≥mo se pueden manejar.

---

### üìÇ Errores al leer archivos

| Error                  | Causa com√∫n                                       | Soluci√≥n                           |
|------------------------|--------------------------------------------------|------------------------------------|
| `FileNotFoundError`    | El archivo no existe o la ruta es incorrecta     | Verifica ruta o usa `try/except`   |
| `PermissionError`      | No tienes permiso para leer o escribir el archivo | Cambia permisos o la ubicaci√≥n     |
| `IsADirectoryError`    | Se intent√≥ abrir una carpeta como si fuera archivo | Aseg√∫rate de apuntar a un archivo  |

```{python}
try:
    with open("datos.csv") as f:
        contenido = f.read()
except FileNotFoundError:
    print("El archivo no se encontr√≥.")
```

---

### üìù Errores al modificar datos

| Error              | Causa com√∫n                             | Soluci√≥n                             |
|--------------------|------------------------------------------|--------------------------------------|
| `IndexError`       | Acceder a un √≠ndice fuera de rango       | Verifica longitud con `len()`        |
| `KeyError`         | Clave no existente en un diccionario     | Usa `.get()` o `in` para validar     |
| `TypeError`        | Operaci√≥n inv√°lida entre tipos distintos | Aseg√∫rate de usar tipos compatibles  |
| `ValueError`       | Conversi√≥n incorrecta de datos           | Usa `try/except` para validarlo      |

```{python}
datos = {"nombre": "Ana"}
print(datos.get("edad", "No especificado"))  # Evita KeyError
```

---

### üåê Errores en conexiones a bases de datos o servidores

| Error                        | Causa com√∫n                                    | Soluci√≥n                              |
|------------------------------|-----------------------------------------------|---------------------------------------|
| `ConnectionError`            | Falla al conectarse a una base o servidor     | Verifica URL/IP, puertos y conexi√≥n   |
| `TimeoutError`               | El servidor no respondi√≥ en tiempo esperado   | Aumenta el timeout o revisa red       |
| `AuthenticationError`*       | Credenciales incorrectas                      | Verifica usuario/contrase√±a           |
| `OperationalError` (SQL)     | Error general en conexi√≥n SQL                 | Revisa cadena de conexi√≥n o driver    |

> *Estos errores pueden variar seg√∫n el paquete (`requests`, `pymysql`, `sqlalchemy`, etc.)

```{python}
import requests

try:
    r = requests.get("https://servidor-ficticio.com", timeout=5)
except requests.exceptions.RequestException as e:
    print("Error de conexi√≥n:", e)
```

---

### ‚öôÔ∏è Otros errores frecuentes

| Error              | Causa                                           |
|--------------------|------------------------------------------------|
| `NameError`        | Usar una variable que no ha sido definida      |
| `AttributeError`   | Intentar usar un m√©todo que no existe para un objeto |
| `ImportError`      | M√≥dulo no encontrado al usar `import`          |
| `SyntaxError`      | Error de escritura del c√≥digo (estructural)    |
| `IndentationError` | Sangr√≠a incorrecta (espacios/tabs mezclados)   |

```{python}
try:
    print(variable_no_definida)
except NameError:
    print("La variable no ha sido definida.")
```






## üß± 9. Importaci√≥n de m√≥dulos en Python

Python cuenta con una enorme cantidad de **m√≥dulos y librer√≠as** que extienden sus funcionalidades. Puedes importar tanto m√≥dulos incluidos por defecto como otros instalados con `pip`.

---

### üì¶ Importar m√≥dulos est√°ndar

Se hace con la palabra clave `import`. Algunos ejemplos comunes:

```{python}
import math
import random
```

Tambi√©n puedes importar funciones espec√≠ficas:

```{python}
from math import sqrt, pi
```

O usar un **alias** para abreviar:

```{python}
import numpy as np
```

---

### üî¢ Ejemplos con m√≥dulos integrados

#### `math`: operaciones matem√°ticas avanzadas

```{python}
import math

print(math.sqrt(25))    # Ra√≠z cuadrada
print(math.pi)          # Pi
print(math.sin(math.radians(90)))  # Seno de 90 grados
```

#### `random`: n√∫meros aleatorios

```{python}
import random

print(random.randint(1, 10))        # N√∫mero entero aleatorio
print(random.choice(["rojo", "azul", "verde"]))  # Selecci√≥n aleatoria
```

---

### üåç Instalar y usar librer√≠as externas con `pip`

`pip` es el **gestor de paquetes** de Python. Con √©l puedes instalar librer√≠as de terceros desde internet:

```bash
pip install nombre_del_paquete
```

Por ejemplo:

```bash
pip install pandas
pip install matplotlib
```

Luego puedes importarlas en tu c√≥digo:

```{python}
import pandas as pd
import matplotlib.pyplot as plt
```

---

### üß† ¬øD√≥nde buscar paquetes √∫tiles?

- https://pypi.org ‚Üí Repositorio oficial de paquetes (`pip`)
- https://awesome-python.com/ ‚Üí Lista curada por categor√≠as
- Documentaci√≥n de librer√≠as como `pandas`, `numpy`, `scikit-learn`, etc.

---


## üß± 10. Lectura y escritura de archivos en Python

Python permite leer y escribir archivos de texto f√°cilmente. Esto es √∫til para guardar informaci√≥n, leer datos externos o generar reportes.

---

### üìñ Abrir archivos con `open()`

La funci√≥n `open()` se usa para abrir archivos. Tiene dos argumentos principales:

- `nombre`: el nombre o ruta del archivo
- `modo`: c√≥mo se va a abrir:
  - `"r"` ‚Üí lectura (default)
  - `"w"` ‚Üí escritura (sobrescribe)
  - `"a"` ‚Üí escritura (agrega al final)
  - `"r+"` ‚Üí lectura y escritura

```{python}
archivo = open("ejemplo.txt", "w")  # Abre para escribir
archivo.write("Hola mundo\n")       # Escribe una l√≠nea
archivo.close()                     # Cierra el archivo
```



```{python}
import os
print(os.getcwd())

```


### üìò Leer archivos

```{python}
archivo = open("ejemplo.txt", "r")
contenido = archivo.read()
print(contenido)
archivo.close()
```

O puedes leer l√≠nea por l√≠nea:

```{python}
archivo = open("ejemplo.txt", "r")
for linea in archivo:
    print(linea.strip())  # strip() elimina saltos de l√≠nea
archivo.close()
```

---

### ‚úÖ Uso recomendado: `with`

Usar `with` es una forma m√°s segura y limpia de trabajar con archivos. Cierra autom√°ticamente el archivo.

```{python}
with open("ejemplo.txt", "a") as archivo:
    archivo.write("Otra l√≠nea\n")
```

Leer con `with`:

```{python}
with open("ejemplo.txt", "r") as archivo:
    for linea in archivo:
        print(linea.strip())
```

---

### ‚úèÔ∏è Escritura: `write()` y `writelines()`

```{python}
lineas = ["Primera l√≠nea\n", "Segunda l√≠nea\n"]

with open("salida.txt", "w") as f:
    f.writelines(lineas)
```

---

### ‚ö†Ô∏è Notas importantes

- Siempre **cierra los archivos** si no usas `with`
- Usa `try/except` para manejar errores si el archivo no existe o hay problemas de acceso
- Puedes usar rutas relativas (`"archivo.txt"`) o absolutas (`"C:/ruta/archivo.txt"`)






## üß± 11. Introducci√≥n a la programaci√≥n orientada a objetos (POO)

La **programaci√≥n orientada a objetos (OOP)** permite modelar conceptos del mundo real mediante *clases*, *objetos*, *atributos* y *m√©todos*. Es muy √∫til para organizar y reutilizar el c√≥digo en programas complejos.

---

### üß© ¬øQu√© es una clase?

Una **clase** es un molde o plantilla para crear objetos. Define qu√© atributos (variables) y m√©todos (funciones) tendr√°n los objetos.

```{python}
class Persona:
    pass  # Clase vac√≠a
```

---

### üßç Crear objetos

Un **objeto** es una instancia de una clase.

```{python}
persona1 = Persona()
print(type(persona1))  # <class '__main__.Persona'>
```

---

### üèóÔ∏è M√©todo constructor `__init__` y `self`

`__init__` se ejecuta autom√°ticamente al crear un objeto. `self` representa al objeto mismo (como `this` en otros lenguajes).

```{python}
class Persona:
    def __init__(self, nombre, edad):
        self.nombre = nombre
        self.edad = edad
```

---

### üì¶ Atributos

Los atributos son las variables asociadas a cada objeto.

```{python}
p = Persona("Ana", 30)
print(p.nombre)
print(p.edad)
```

---

### ‚öôÔ∏è M√©todos

Los m√©todos son funciones definidas dentro de una clase que act√∫an sobre el objeto.

```{python}
class Persona:
    def __init__(self, nombre):
        self.nombre = nombre
    
    def saludar(self):
        print(f"Hola, soy {self.nombre}")

p = Persona("Luis")
p.saludar()
```

---

### üß† Buenas pr√°cticas

- Los nombres de clases se escriben en **May√∫sculas** (CamelCase)
- Los nombres de m√©todos y atributos van en **min√∫sculas_con_guiones_bajos**
- Siempre debe ir `self` como primer par√°metro de los m√©todos (incluso si no se usa)

---


---

## üìå Ap√©ndice: Herencia y clases hijas en Python

En programaci√≥n orientada a objetos, la **herencia** permite crear nuevas clases a partir de clases existentes. Las clases hijas **heredan** atributos y m√©todos de la clase padre, y pueden agregar o modificar su comportamiento.

---

### üß¨ Clase hija que hereda de una clase padre

```{python}
class Animal:
    def __init__(self, nombre):
        self.nombre = nombre

    def hablar(self):
        print("Este animal no hace sonido.")

# Clase hija
class Perro(Animal):
    def hablar(self):
        print(f"{self.nombre} dice: ¬°Guau!")

p = Perro("Toby")
p.hablar()
```

‚úîÔ∏è La clase `Perro` hereda de `Animal` y **reescribe** el m√©todo `hablar()`.

---

### üîÅ Usar `super()` para reutilizar el constructor

Si quieres extender el constructor de la clase padre en la hija, usa `super()`:

```{python}
class Persona:
    def __init__(self, nombre, edad):
        self.nombre = nombre
        self.edad = edad

class Estudiante(Persona):
    def __init__(self, nombre, edad, carrera):
        super().__init__(nombre, edad)
        self.carrera = carrera

e = Estudiante("Ana", 20, "Matem√°ticas")
print(e.nombre, e.edad, e.carrera)
```

---

### üß† ¬øCu√°ndo usar herencia?

- Cuando varias clases **comparten comportamientos comunes**.
- Para **evitar duplicar c√≥digo**.
- Para extender o especializar clases existentes.

Evita usar herencia **cuando no hay una relaci√≥n clara de tipo "es-un"**. A veces es mejor usar composici√≥n (`tiene-un`) o simplemente funciones separadas.

---

## üß™ Ejercicios extra

1. Crea una clase `Empleado` con nombre y sueldo. Luego crea una clase hija `Gerente` con un atributo extra `departamento` y un m√©todo `mostrar_informacion()`.
2. Crea una clase `Vehiculo` con m√©todo `mover()`, y dos clases hijas `Auto` y `Bicicleta` que sobrescriban ese m√©todo con diferentes mensajes.
3. Crea una clase `Figura` con m√©todo `area()` y `perimetro()`, y luego crea `Cuadrado` y `C√≠rculo` como clases hijas.

---

Esta base te permitir√° construir jerarqu√≠as de clases limpias y reutilizables üß±üß¨







