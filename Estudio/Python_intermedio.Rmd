---
title: "Python Intermedio"
author: "Fernando Alvarado"
date: "2025-04-16"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


## üß± 12. Comprensi√≥n profunda de estructuras de datos

Python permite trabajar con estructuras de datos de forma muy flexible y expresiva. Aqu√≠ exploraremos **listas y diccionarios por comprensi√≥n**, el uso **eficiente de `set` y `tuple`**, y t√©cnicas para manipular listas y diccionarios de forma avanzada.

---

### üß† Listas por comprensi√≥n (List Comprehension)

Permiten crear listas nuevas a partir de otras secuencias con una sintaxis compacta.

```{python}
# Crear una lista de cuadrados del 1 al 10
cuadrados = [x**2 for x in range(1, 11)]
print(cuadrados)

# Filtrar n√∫meros pares
pares = [x for x in range(20) if x % 2 == 0]
print(pares)
```

---

### üîë Diccionarios por comprensi√≥n

Igual que las listas, pero usando la sintaxis `{clave:valor for ...}`.

```{python}
# Crear un diccionario de n√∫mero ‚Üí cuadrado
cuadrados = {x: x**2 for x in range(1, 6)}
print(cuadrados)

# Convertir dos listas en un diccionario
nombres = ["Ana", "Luis", "Marta"]
edades = [25, 30, 22]
personas = {n: e for n, e in zip(nombres, edades)}
print(personas)
```

---

### üîò Uso eficiente de `set` y `tuple`

- `set` elimina duplicados autom√°ticamente y permite operaciones como intersecci√≥n, uni√≥n, etc.
- `tuple` se usa cuando los datos **no deben cambiar** (inmutabilidad).

```{python}
# Eliminar duplicados
numeros = [1, 2, 2, 3, 4, 4]
unicos = set(numeros)
print(unicos)

# Comparar dos listas
a = {1, 2, 3}
b = {3, 4, 5}
print(a & b)  # Intersecci√≥n
print(a | b)  # Uni√≥n

# Usar tuplas como claves de diccionario
coords = {(0, 0): "origen", (1, 2): "punto A"}
print(coords[(1, 2)])
```

---

### üõ†Ô∏è Manipulaci√≥n avanzada de listas

Algunas t√©cnicas √∫tiles con listas:

```{python}
numeros = [1, 2, 3, 4, 5, 6]

# Rebanado (slicing)
print(numeros[1:4])     # Elementos del √≠ndice 1 al 3
print(numeros[::-1])    # Lista invertida

# Eliminar elementos por condici√≥n
numeros = [x for x in numeros if x % 2 != 0]
print(numeros)

# Map y filter
cuadrados = list(map(lambda x: x**2, [1, 2, 3]))
pares = list(filter(lambda x: x % 2 == 0, range(10)))
```

---

### üõ†Ô∏è Manipulaci√≥n avanzada de diccionarios

```{python}
datos = {"a": 1, "b": 2, "c": 3}

# Acceder a claves y valores
for clave, valor in datos.items():
    print(clave, "‚Üí", valor)

# Invertir claves y valores
inverso = {v: k for k, v in datos.items()}
print(inverso)

# Filtrar claves por condici√≥n
filtrado = {k: v for k, v in datos.items() if v % 2 != 0}
print(filtrado)
```

---

## üß™ Ejercicios pr√°cticos

1. Crea una lista por comprensi√≥n con los n√∫meros del 1 al 30 que sean m√∫ltiplos de 3.
2. Dado un diccionario de alumnos ‚Üí calificaci√≥n, crea otro que solo contenga a los aprobados (>= 6).
3. Elimina los duplicados de una lista de frutas y ord√©nala alfab√©ticamente.
4. Invierte las claves y valores de un diccionario simple.
5. Usando `zip`, convierte dos listas (`nombres`, `notas`) en un diccionario.
6. Crea una lista con las palabras de una oraci√≥n que tengan m√°s de 4 letras.

---

¬øTe gustar√≠a continuar con funciones lambda, uso de `map`/`filter` m√°s a fondo o saltamos a visualizaci√≥n de datos? üßÆüìä


---

## üìå Ap√©ndice: Funciones `lambda` y funciones de orden superior

Python permite usar **funciones an√≥nimas** (`lambda`) y pasar funciones como argumentos, lo que da lugar a funciones de **orden superior**. Esto es muy √∫til para trabajar con listas, filtros y operaciones funcionales.

---

### ‚ö° Funciones `lambda`

Una `lambda` es una funci√≥n peque√±a y sin nombre, escrita en una sola l√≠nea.

```{python}
# Funci√≥n tradicional
def cuadrado(x):
    return x ** 2

# Equivalente lambda
cuadrado_lambda = lambda x: x ** 2

print(cuadrado(4))
print(cuadrado_lambda(4))
```

Tambi√©n puede recibir varios par√°metros:

```{python}
sumar = lambda a, b: a + b
print(sumar(3, 5))  # 8
```

---

### üß† Funciones de orden superior

Son funciones que reciben otras funciones como argumento. Ejemplos integrados en Python:

#### `map(function, iterable)`

Aplica la funci√≥n a cada elemento del iterable.

```{python}
numeros = [1, 2, 3, 4]
cuadrados = list(map(lambda x: x**2, numeros))
print(cuadrados)
```

#### `filter(function, iterable)`

Filtra los elementos para los que la funci√≥n devuelve `True`.

```{python}
pares = list(filter(lambda x: x % 2 == 0, range(10)))
print(pares)
```

#### `sorted(iterable, key=func)`

Ordena elementos usando una funci√≥n como criterio.

```{python}
nombres = ["ana", "Luis", "MARTA", "pedro"]
ordenados = sorted(nombres, key=lambda x: x.lower())
print(ordenados)
```

---

### ‚úÖ Cu√°ndo usar `lambda` y funciones de orden superior

- Cuando necesitas una funci√≥n sencilla y **no quieres definirla por separado**.
- Para **operaciones r√°pidas** sobre listas, diccionarios, etc.
- Cuando trabajas con **estructuras funcionales** como `map`, `filter`, `sorted`, `max`, `min`, etc.

---

## üß™ Ejercicios extra

1. Usa `map` y `lambda` para elevar al cubo todos los elementos de una lista `[1, 2, 3, 4, 5]`.
2. Usa `filter` para conservar solo las palabras que empiezan con vocal en una lista.
3. Ordena una lista de tuplas `(nombre, edad)` por edad usando `lambda`.
4. Crea una lista de funciones lambda que calculen: doble, triple y cuadrado de un n√∫mero, y apl√≠calas a un mismo valor.

---

Este ap√©ndice te da herramientas poderosas para escribir c√≥digo m√°s expresivo y compacto ‚öôÔ∏èüß†



## üß± 13. Funciones avanzadas en Python

Las funciones en Python son extremadamente vers√°tiles: pueden ser an√≥nimas (`lambda`), recibir un n√∫mero variable de argumentos, usarse como objetos y decorarse para extender su funcionalidad. Aqu√≠ cubrimos lo esencial de su uso avanzado.

---

### ‚ö° Funciones an√≥nimas (`lambda`)

Son funciones sin nombre, √∫tiles para operaciones r√°pidas y de una sola l√≠nea.

```{python}
# Funci√≥n lambda que duplica un n√∫mero
doble = lambda x: x * 2
print(doble(4))  # 8

# Lambda con m√∫ltiples argumentos
suma = lambda a, b: a + b
print(suma(2, 3))  # 5
```

---

### ‚ú≥Ô∏è Argumentos variables: `*args` y `**kwargs`

- `*args`: permite pasar **cualquier cantidad de argumentos posicionales** (como una tupla).
- `**kwargs`: permite pasar **argumentos con nombre** (como un diccionario).

```{python}
def mostrar_args(*args):
    for arg in args:
        print("Posicional:", arg)

def mostrar_kwargs(**kwargs):
    for clave, valor in kwargs.items():
        print(f"{clave} = {valor}")

mostrar_args(1, 2, 3)
mostrar_kwargs(nombre="Ana", edad=30)
```

Puedes combinar ambos:

```{python}
def ejemplo_completo(a, *args, **kwargs):
    print("a:", a)
    print("args:", args)
    print("kwargs:", kwargs)

ejemplo_completo(1, 2, 3, x=10, y=20)
```

---

### üßµ Decoradores (`@decorador`)

Un **decorador** es una funci√≥n que **envuelve a otra** para modificar o extender su comportamiento.

```{python}
def decorador(func):
    def nueva_funcion():
        print("Antes de la funci√≥n")
        func()
        print("Despu√©s de la funci√≥n")
    return nueva_funcion

@decorador
def saludar():
    print("Hola mundo")

saludar()
```

Esto equivale a:

```{python}
saludar = decorador(saludar_original)
```

---

### üéÅ Closures y funciones como objetos de primera clase

En Python, las funciones son objetos: se pueden **guardar en variables, pasar como argumentos y retornar** desde otras funciones.

#### Closure: funci√≥n interna que recuerda el contexto de la externa

```{python}
def crear_multiplicador(factor):
    def multiplicar(x):
        return x * factor
    return multiplicar

doble = crear_multiplicador(2)
print(doble(5))  # 10
```

---

## üß™ Ejercicios pr√°cticos

1. Crea una funci√≥n que reciba `*args` y devuelva la suma de todos los n√∫meros pasados.
2. Define una funci√≥n que imprima los valores de cualquier `**kwargs` que reciba.
3. Escribe un decorador que registre (imprima) la hora en la que se ejecuta una funci√≥n.
4. Crea una funci√≥n `crear_saludo(nombre)` que devuelva una funci√≥n que, al llamarla, diga `"Hola <nombre>"`.
5. Crea una lista de funciones lambda que hagan `x+1`, `x+2` y `x+3`, y apl√≠calas sobre un valor `10`.

---

¬øQuieres que sigamos con programaci√≥n funcional, generadores/iteradores, o entramos a visualizaci√≥n de datos? üßÆüìäüîÑ



---

## üìå Ap√©ndice: Programaci√≥n funcional y generadores

Python permite aplicar conceptos de **programaci√≥n funcional**, como funciones puras, inmutabilidad y composici√≥n. Tambi√©n permite crear **generadores**, funciones que producen valores bajo demanda y consumen poca memoria.

---

### üß† Programaci√≥n funcional

En este paradigma:

- Las funciones son **ciudadanos de primera clase**
- Se favorece la **inmutabilidad** (no modificar estados)
- Se promueve el uso de funciones puras (sin efectos secundarios)

#### Funciones √∫tiles: `map()`, `filter()`, `reduce()`

```{python}
# map: aplica una funci√≥n a cada elemento
numeros = [1, 2, 3, 4]
cuadrados = list(map(lambda x: x**2, numeros))

# filter: selecciona elementos que cumplen una condici√≥n
pares = list(filter(lambda x: x % 2 == 0, numeros))

# reduce: acumula un resultado (requiere importar)
from functools import reduce
suma_total = reduce(lambda x, y: x + y, numeros)
```

---

### üîÅ Generadores

Un **generador** es una funci√≥n que **produce una secuencia de valores**, uno a la vez, usando `yield` en lugar de `return`.

```{python}
def contador(maximo):
    n = 1
    while n <= maximo:
        yield n
        n += 1

for num in contador(5):
    print(num)
```

‚úÖ Ventajas:
- Bajo consumo de memoria
- √ötil para trabajar con datos grandes o secuencias infinitas

---

### üîÑ Expresiones generadoras

M√°s compactas que las funciones generadoras:

```{python}
gen = (x**2 for x in range(5))
for val in gen:
    print(val)
```

---

### üß™ Ejercicios extra

1. Usa `map()` para convertir una lista de temperaturas en ¬∞C a ¬∞F.
2. Usa `filter()` para obtener los nombres que empiezan con vocal de una lista.
3. Escribe una funci√≥n generadora que produzca los primeros `n` m√∫ltiplos de 3.
4. Escribe una expresi√≥n generadora que produzca los cuadrados de los n√∫meros del 1 al 10.
5. Crea una funci√≥n generadora que simule una cuenta regresiva desde `n` hasta 0.

---

Este ap√©ndice te permite escribir c√≥digo m√°s **elegante, eficiente y expresivo** üåÄ




## üß± 14. Programaci√≥n orientada a objetos (OOP) - Parte 2

En esta lecci√≥n exploramos conceptos avanzados de la Programaci√≥n Orientada a Objetos en Python: **herencia**, **polimorfismo**, **encapsulamiento**, **m√©todos m√°gicos**, **propiedades** y **clases abstractas**.

---

### üß¨ Herencia (repaso breve)

Permite que una clase hija herede atributos y m√©todos de una clase padre.

```{python}
class Animal:
    def hablar(self):
        print("Hace un sonido")

class Perro(Animal):
    def hablar(self):
        print("Guau")

p = Perro()
p.hablar()
```

---

### üåÄ Polimorfismo

Significa que una misma interfaz puede tener m√∫ltiples implementaciones.

```{python}
def hacer_hablar(animal):
    animal.hablar()

class Gato:
    def hablar(self):
        print("Miau")

g = Gato()
hacer_hablar(p)  # Guau
hacer_hablar(g)  # Miau
```

---

### üîí Encapsulamiento

Controla el acceso a los atributos de un objeto:

- `_atributo`: convenci√≥n de "protegido"
- `__atributo`: atributo "privado" (name mangling)

```{python}
class Cuenta:
    def __init__(self, saldo):
        self.__saldo = saldo

    def mostrar_saldo(self):
        return self.__saldo

cuenta = Cuenta(1000)
print(cuenta.mostrar_saldo())
# print(cuenta.__saldo)  # Error
```

---

### ‚ú® M√©todos m√°gicos

Son funciones especiales con doble guion bajo. Algunos √∫tiles:

```{python}
class Libro:
    def __init__(self, titulo):
        self.titulo = titulo

    def __str__(self):
        return f"Libro: {self.titulo}"

    def __eq__(self, otro):
        return self.titulo == otro.titulo

    def __len__(self):
        return len(self.titulo)

l1 = Libro("Python")
l2 = Libro("Python")
print(str(l1))      # Libro: Python
print(l1 == l2)     # True
print(len(l1))      # 6
```

---

### ‚öôÔ∏è Propiedades con `@property`

Permite acceder a m√©todos como si fueran atributos, √∫til para validar datos.

```{python}
class Producto:
    def __init__(self, precio):
        self._precio = precio

    @property
    def precio(self):
        return self._precio

    @precio.setter
    def precio(self, valor):
        if valor >= 0:
            self._precio = valor
        else:
            raise ValueError("Precio no puede ser negativo")

p = Producto(50)
p.precio = 100
print(p.precio)
```

---

### üß± Clases abstractas y m√©todos abstractos

Sirven como base para otras clases. No se pueden instanciar directamente.

```{python}
from abc import ABC, abstractmethod

class Figura(ABC):
    @abstractmethod
    def area(self):
        pass

class Cuadrado(Figura):
    def __init__(self, lado):
        self.lado = lado

    def area(self):
        return self.lado ** 2
```

---

## üß™ Ejercicios pr√°cticos

1. Crea una clase `Vehiculo` con un m√©todo `mover()`. Luego crea `Auto` y `Bicicleta` que sobrescriban ese m√©todo.
2. Crea una clase `Empleado` con atributo privado `__sueldo` y un m√©todo `mostrar_sueldo()`.
3. Implementa la clase `Libro` con `__str__`, `__len__` y `__eq__`.
4. Crea una clase `Rectangulo` con propiedades `base` y `altura` que no permitan valores negativos.
5. Define una clase abstracta `Instrumento` con m√©todo abstracto `tocar()`, y luego una clase `Guitarra` que la implemente.

---

¬øTe gustar√≠a continuar con estructuras de datos personalizadas, testing o bases de datos con `sqlite3` o `pandas`? üß™üìÇüìã



## üß± 15. Manejo de excepciones avanzado

Adem√°s de capturar errores comunes, Python permite crear **excepciones personalizadas** y trabajar con **context managers** para manejar recursos de forma segura y elegante.

---

### üö® Excepciones personalizadas

Puedes definir tus propias clases de error heredando de `Exception`. Esto te permite lanzar errores espec√≠ficos y controlarlos claramente.

```{python}
class DivisionPorCeroError(Exception):
    pass

def dividir(a, b):
    if b == 0:
        raise DivisionPorCeroError("No se puede dividir entre cero")
    return a / b

try:
    dividir(10, 0)
except DivisionPorCeroError as e:
    print("Error personalizado:", e)
```

‚úîÔ∏è Puedes crear jerarqu√≠as de excepciones si tu aplicaci√≥n es grande.

---

### üì¶ Context Managers (`with`, `__enter__`, `__exit__`)

Los context managers **gestionan recursos** (archivos, conexiones, etc.) autom√°ticamente.

```{python}
with open("archivo.txt", "w") as f:
    f.write("Hola mundo")
# El archivo se cierra autom√°ticamente
```

Tambi√©n puedes **crear tus propios context managers** con `__enter__` y `__exit__`.

```{python}
class MiContexto:
    def __enter__(self):
        print("Entrando al contexto")
        return self

    def __exit__(self, tipo, valor, traza):
        print("Saliendo del contexto")

with MiContexto():
    print("Dentro del bloque")
```

- `__enter__()` se ejecuta al entrar en el bloque `with`.
- `__exit__()` se ejecuta al salir, y puede recibir informaci√≥n del error si ocurri√≥.

---

### üß† Cu√°ndo usar context managers

- Para **abrir y cerrar archivos**
- Para **conectar a bases de datos**
- Para **bloquear recursos** (como hilos o procesos)
- Para **manejar recursos que deben limpiarse** aunque haya errores

---

## üß™ Ejercicios pr√°cticos

1. Crea una excepci√≥n personalizada `EdadInvalidaError` que se lance si la edad ingresada es negativa.
2. Crea una funci√≥n `leer_archivo(path)` que devuelva el contenido y capture `FileNotFoundError`.
3. Implementa un context manager llamado `Temporizador` que imprima cu√°ndo se entra y sale del bloque `with`.
4. Crea una clase `ConexionFalsa` con m√©todos `__enter__` y `__exit__`, y dentro del contexto imprime "Conectado" y al salir "Desconectado".

---

¬øQuieres continuar con manejo de archivos CSV/JSON, conexi√≥n a bases de datos o pruebas automatizadas? üìÇüß™üßæ





## üß± 16. M√≥dulos y paquetes en Python

Una de las ventajas de Python es que puedes **organizar tu c√≥digo en archivos reutilizables** llamados **m√≥dulos** y agruparlos en **paquetes**. Esto mejora la mantenibilidad, legibilidad y escalabilidad de tus programas.

---

### üì¶ Organizaci√≥n del c√≥digo en m√≥dulos

Un **m√≥dulo** es simplemente un archivo `.py` con funciones, clases o variables que puedes importar en otros archivos.

```python
# archivo: utilidades.py
def saludar(nombre):
    return f"Hola, {nombre}"
```

```python
# archivo: main.py
import utilidades

print(utilidades.saludar("Ana"))
```

Tambi√©n puedes importar solo lo que necesitas:

```python
from utilidades import saludar
print(saludar("Luis"))
```

---

### üìÅ Paquetes y `__init__.py`

Un **paquete** es una carpeta que contiene un archivo `__init__.py`. Ese archivo puede estar vac√≠o, pero indica que la carpeta es un **paquete importable**.

```text
mi_proyecto/
‚îÇ
‚îú‚îÄ‚îÄ paquete/
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îú‚îÄ‚îÄ modulo1.py
‚îÇ   ‚îî‚îÄ‚îÄ modulo2.py
‚îî‚îÄ‚îÄ main.py
```

Importaci√≥n:

```python
from paquete.modulo1 import funcion_x
```

‚úîÔ∏è Puedes colocar funciones comunes en `__init__.py` para importarlas directamente desde el paquete.

---

### üß≠ Importaciones absolutas y relativas

#### üîπ Importaci√≥n absoluta

Desde la ra√≠z del proyecto:

```python
from paquete.modulo1 import funcion_x
```

#### üî∏ Importaci√≥n relativa

Desde dentro del paquete:

```python
from .modulo1 import funcion_x        # Importar desde mismo nivel
from ..subpaquete.modulo3 import y    # Subir un nivel
```

‚úÖ Usar importaciones absolutas es m√°s claro en proyectos grandes.  
Las relativas son √∫tiles cuando tu paquete est√° aislado del entorno principal.

---

### ‚ö†Ô∏è Buenas pr√°cticas

- Usa nombres descriptivos para m√≥dulos (`analisis_datos.py`, no `util.py`)
- Agrupa m√≥dulos por tema dentro de paquetes
- Evita ciclos de importaci√≥n (m√≥dulos que se importan entre s√≠ recursivamente)
- Usa `__all__` en `__init__.py` para controlar qu√© se expone al importar con `*`

---

## üß™ Ejercicios pr√°cticos

1. Crea un archivo `matematica.py` con funciones `suma(a,b)` y `resta(a,b)`. Luego crea `main.py` para usarlas.
2. Crea un paquete `calculadora` con dos m√≥dulos: `aritmetica.py` y `geometria.py`. Prueba importar desde ambos.
3. Dentro de `__init__.py`, importa por defecto una funci√≥n llamada `bienvenida()`.
4. Practica una importaci√≥n relativa desde un m√≥dulo `modulo_b.py` hacia `modulo_a.py` dentro del mismo paquete.
5. Crea un proyecto completo con estructura modular y comenta para qu√© sirve cada archivo.

---

¬øQuieres seguir con archivos CSV y JSON, bases de datos (`sqlite3`), o desarrollo de entornos virtuales y distribuci√≥n de paquetes? üßæüóÉÔ∏èüì¶





## üß± 17. Manejo de archivos m√°s all√° del texto

Python permite trabajar no solo con archivos de texto plano, sino tambi√©n con **archivos binarios** y **formatos estructurados** como `CSV` y `JSON`, muy comunes en ciencia de datos, bases de datos y APIs.

---

### üßä Lectura y escritura de archivos binarios

Usa los modos `'rb'` (lectura binaria) y `'wb'` (escritura binaria). Es √∫til para im√°genes, archivos PDF, audio, etc.

```{python}
# Guardar archivo binario
with open("imagen.jpg", "rb") as archivo_original:
    contenido = archivo_original.read()

with open("copia.jpg", "wb") as copia:
    copia.write(contenido)
```

‚úÖ Los archivos binarios manejan **bytes**, no texto. No puedes usar `.readline()` ni `.write("texto")`.

---

### üìë Lectura y escritura de CSV

#### Usando el m√≥dulo `csv`

```{python}
import csv

# Escribir archivo CSV
with open("personas.csv", "w", newline="") as archivo:
    escritor = csv.writer(archivo)
    escritor.writerow(["Nombre", "Edad"])
    escritor.writerow(["Ana", 30])
    escritor.writerow(["Luis", 25])

# Leer archivo CSV
with open("personas.csv", "r") as archivo:
    lector = csv.reader(archivo)
    for fila in lector:
        print(fila)
```

#### Como diccionarios

```{python}
# Leer como diccionario
with open("personas.csv", "r") as archivo:
    lector = csv.DictReader(archivo)
    for fila in lector:
        print(fila["Nombre"], "‚Üí", fila["Edad"])
```

---

### üîÅ Lectura y escritura de JSON

`JSON` es un formato muy usado para **intercambio de datos**, especialmente en APIs.

```{python}
import json

datos = {"nombre": "Ana", "edad": 30, "activo": True}

# Escribir archivo JSON
with open("datos.json", "w") as archivo:
    json.dump(datos, archivo, indent=4)

# Leer archivo JSON
with open("datos.json", "r") as archivo:
    cargado = json.load(archivo)
    print(cargado["nombre"])
```

---

### üß† ¬øCu√°l usar?

| Formato | Ideal para                        |
|---------|-----------------------------------|
| Binario | Im√°genes, audio, video, archivos grandes |
| CSV     | Datos tabulares simples (hojas de c√°lculo, bases de datos) |
| JSON    | Intercambio de datos estructurados (APIs, configuraci√≥n)  |

---

## üß™ Ejercicios pr√°cticos

1. Copia una imagen `.jpg` usando `rb` y `wb`.
2. Crea un archivo `productos.csv` con columnas `nombre`, `precio`, `stock`. Escribe 3 productos y luego l√©elos.
3. Guarda un diccionario en formato `JSON` y recup√©ralo desde el archivo.
4. Lee un CSV con `DictReader` e imprime solo los productos cuyo `stock` sea mayor a 10.
5. Transforma un archivo JSON cargado en un diccionario y modifica uno de sus valores antes de volver a guardarlo.

---

¬øTe gustar√≠a que lo siguiente sea sobre consumo de APIs con `requests`, conexi√≥n a bases de datos o gr√°ficos con `matplotlib`? üåêüì°üìä




---

## üìå Ap√©ndice: Consumo de APIs con `requests`

Muchas aplicaciones modernas se comunican con servicios externos a trav√©s de **APIs (Application Programming Interfaces)**. En Python, el paquete `requests` permite **realizar solicitudes HTTP f√°cilmente**.

---

### üåê ¬øQu√© es una API?

Una API expone datos o funcionalidades mediante URLs. Puedes obtener datos en formatos como `JSON` o `XML`.

Ejemplo:  
`https://api.chucknorris.io/jokes/random` ‚Üí Devuelve un chiste aleatorio en formato JSON.

---

### ‚öôÔ∏è Instalaci√≥n del paquete

```bash
pip install requests
```

---

### üîÑ Realizar una solicitud `GET`

```{python}
import requests

url = "https://api.chucknorris.io/jokes/random"
respuesta = requests.get(url)

if respuesta.status_code == 200:
    datos = respuesta.json()
    print("Chiste:", datos["value"])
else:
    print("Error al conectar con la API")
```

- `.get()` ‚Üí realiza la solicitud
- `.json()` ‚Üí convierte la respuesta a diccionario
- `.status_code` ‚Üí revisa si fue exitosa (200 = OK)

---

### üì§ Enviar datos con `POST`

```{python}
url = "https://httpbin.org/post"
datos = {"usuario": "Ana", "clave": "123"}

respuesta = requests.post(url, json=datos)
print(respuesta.json())
```

Usamos `.post()` para enviar datos, t√≠picamente en JSON o formularios.

---

### ‚ö†Ô∏è Buenas pr√°cticas

- Revisa el c√≥digo de estado antes de acceder a `.json()`
- Usa `try/except` para manejar errores de conexi√≥n
- No expongas claves API ni credenciales directamente en el c√≥digo

---

## üß™ Ejercicios extra

1. Consulta la API de Chuck Norris y guarda 3 chistes distintos en una lista.
2. Consulta la API de Pok√©mon (`https://pokeapi.co/api/v2/pokemon/ditto`) y extrae su nombre y habilidades.
3. Env√≠a un `POST` con tus datos a `https://httpbin.org/post` y observa la respuesta.
4. Usa `try/except` para capturar errores de conexi√≥n o respuestas inv√°lidas.
5. Revisa la documentaci√≥n de una API p√∫blica de tu inter√©s y haz tu propia consulta.

---

Este ap√©ndice te introduce a la base de aplicaciones web modernas y consumo de datos externos üåêüì°





## üß± 18. Uso de librer√≠as est√°ndar y externas

Python cuenta con una extensa **librer√≠a est√°ndar** y permite instalar **librer√≠as externas** que extienden su funcionalidad para ciencia de datos, web, automatizaci√≥n, etc. En esta lecci√≥n exploramos algunas esenciales.

---

### üß∞ Librer√≠as est√°ndar √∫tiles

#### üîÅ `itertools`: combinatoria y generadores infinitos

```{python}
import itertools

# Producto cartesiano
for a in itertools.product("AB", repeat=2):
    print(a)

# Contador infinito (hasta cierto punto)
for i in itertools.count(10):
    if i > 15:
        break
    print(i)
```

#### üóÉÔ∏è `collections`: estructuras mejoradas

```{python}
from collections import Counter, defaultdict, namedtuple

# Contar frecuencias
contador = Counter("abracadabra")
print(contador)

# Diccionario con valor por defecto
dd = defaultdict(int)
dd["x"] += 1
print(dd)

# Tupla con nombre
Persona = namedtuple("Persona", "nombre edad")
p = Persona("Ana", 30)
print(p.nombre)
```

#### üïí `datetime`: fechas y tiempos

```{python}
from datetime import datetime, timedelta

ahora = datetime.now()
print("Ahora:", ahora)

ma√±ana = ahora + timedelta(days=1)
print("Ma√±ana:", ma√±ana)

print("Solo fecha:", ahora.date())
print("Solo hora:", ahora.time())
```

---

### üåê Librer√≠as externas comunes

#### üåê `requests`: solicitudes HTTP

```{python}
import requests
r = requests.get("https://api.chucknorris.io/jokes/random")
print(r.json()["value"])
```

#### üì¶ `json`: trabajar con JSON

```{python}
import json

diccionario = {"nombre": "Ana", "edad": 30}
texto = json.dumps(diccionario)
recuperado = json.loads(texto)
print(recuperado)
```

#### üíª `os`: interacci√≥n con el sistema operativo

```{python}
import os

print(os.getcwd())            # Directorio actual
print(os.listdir("."))        # Archivos en la carpeta
os.mkdir("nueva_carpeta")     # Crear carpeta
```

#### üñ•Ô∏è `sys`: informaci√≥n del sistema

```{python}
import sys

print(sys.argv)         # Argumentos de l√≠nea de comandos
print(sys.version)      # Versi√≥n de Python
```

---

### üì¶ Manejo de entornos virtuales

Los entornos virtuales permiten **aislar dependencias de proyectos**.

#### ‚úÖ Usando `venv` (incluido en Python)

```bash
python -m venv mi_entorno
source mi_entorno/bin/activate      # Linux/macOS
mi_entorno\Scripts\activate         # Windows

# Luego puedes instalar paquetes
pip install requests
```

#### üêç Usando `conda` (requiere instalaci√≥n previa)

```bash
conda create -n mi_env python=3.11
conda activate mi_env
conda install requests
```

---

## üß™ Ejercicios pr√°cticos

1. Usa `itertools.product` para generar todas las combinaciones posibles entre las letras `"a", "b", "c"` y los n√∫meros `1, 2`.
2. Usa `Counter` para contar las letras en `"banana"`.
3. Muestra la fecha de hoy y la fecha de hace 7 d√≠as usando `datetime`.
4. Crea un archivo JSON desde un diccionario y recup√©ralo.
5. Crea un script que imprima el n√∫mero de argumentos recibidos desde l√≠nea de comandos.
6. Crea un entorno virtual e instala una librer√≠a como `pandas` o `faker`.

---

¬øTe gustar√≠a que prepare una lecci√≥n final sobre distribuci√≥n de paquetes (`setup.py`, PyPI), testing o proyectos integradores? üì¶üß™üîÅ




---

## üìå Ap√©ndice: Testing y depuraci√≥n en Python

Escribir c√≥digo sin errores no siempre es posible, pero Python ofrece herramientas para **probar** (`testing`) y **depurar** (`debugging`) nuestros programas de manera profesional y eficiente.

---

### üß™ Testing: Pruebas automatizadas

#### ‚úÖ Pruebas con `assert`

Para verificar condiciones r√°pidamente durante el desarrollo:

```{python}
def suma(a, b):
    return a + b

assert suma(2, 2) == 4
assert suma(0, 0) == 0
# assert suma(2, 2) == 5  # Levanta AssertionError
```

---

#### üß™ Pruebas con `unittest`

Framework incorporado en la librer√≠a est√°ndar:

```{python}
import unittest

def multiplicar(a, b):
    return a * b

class TestMultiplicacion(unittest.TestCase):
    def test_basico(self):
        self.assertEqual(multiplicar(2, 3), 6)

    def test_con_cero(self):
        self.assertEqual(multiplicar(0, 5), 0)

if __name__ == "__main__":
    unittest.main()
```

‚úÖ Puedes guardar los tests en un archivo separado, como `test_modulo.py`.

---

### üêû Depuraci√≥n (Debugging)

#### üëÄ Usar `print()` (forma b√°sica)

A veces, imprimir variables clave es suficiente para encontrar errores:

```{python}
def dividir(a, b):
    print("a:", a, "b:", b)
    return a / b
```

---

#### üß≠ Usar `pdb`: el depurador interactivo

```{python}
import pdb

def calcular_area(base, altura):
    pdb.set_trace()
    return base * altura

print(calcular_area(3, 5))
```

Durante la ejecuci√≥n puedes usar comandos como:
- `n` ‚Üí siguiente l√≠nea
- `c` ‚Üí continuar ejecuci√≥n
- `p variable` ‚Üí imprimir variable
- `q` ‚Üí salir del depurador

---

#### üß∞ Usar depuradores en editores como VSCode o PyCharm

- Puedes **poner puntos de ruptura (breakpoints)** sin tocar el c√≥digo.
- Te permite **inspeccionar valores** en tiempo real.
- Ideal para proyectos grandes o en producci√≥n.

---

## üß™ Ejercicios extra

1. Usa `assert` para verificar que una funci√≥n `es_par(n)` devuelve `True` si `n` es m√∫ltiplo de 2.
2. Crea un archivo `test_calculadora.py` con 2 pruebas unitarias: una para `suma(a, b)` y otra para `resta(a, b)`.
3. Inserta `pdb.set_trace()` dentro de una funci√≥n con error l√≥gico y explora sus variables paso a paso.
4. Haz que una prueba con `unittest` falle a prop√≥sito y analiza el mensaje de error.
5. Activa el modo debug en tu editor y pon un breakpoint para analizar paso a paso una funci√≥n.

---

Este ap√©ndice te ayuda a escribir **c√≥digo m√°s confiable, robusto y f√°cil de mantener** üß™üêõ





## üß± 19. Procesamiento y limpieza de datos

Python es ampliamente utilizado en an√°lisis de datos. En esta lecci√≥n aprender√°s a usar las librer√≠as **`pandas`** y **`numpy`** para leer, filtrar y transformar datos de forma eficiente.

---

### üì¶ Cargar librer√≠as

```{python}
import pandas as pd
import numpy as np
```

---

### üì• Lectura de datos

`pandas` permite leer archivos CSV, Excel, JSON y m√°s:

```{python}
# Leer archivo CSV
df = pd.read_csv("datos.csv")

# Leer Excel
# df = pd.read_excel("datos.xlsx")

# Vista r√°pida
print(df.head())
print(df.info())
```

---

### üßº Limpieza de datos

#### Identificar y manejar valores faltantes (`NaN`)

```{python}
# Ver si hay valores nulos
print(df.isnull().sum())

# Eliminar filas con NaN
df = df.dropna()

# Rellenar con un valor
df = df.fillna(0)

# Rellenar con la media de la columna
df["columna"] = df["columna"].fillna(df["columna"].mean())
```

---

### üîç Filtrado de datos

```{python}
# Filtrar por condici√≥n
adultos = df[df["edad"] >= 18]

# Filtrar m√∫ltiples condiciones
hombres_mayores = df[(df["sexo"] == "M") & (df["edad"] > 30)]
```

---

### üîÅ Transformaci√≥n de columnas

```{python}
# Crear nueva columna
df["doble_edad"] = df["edad"] * 2

# Aplicar funci√≥n a una columna
df["nombre_mayuscula"] = df["nombre"].apply(str.upper)

# Usar numpy para transformaci√≥n
df["log_ingresos"] = np.log(df["ingresos"] + 1)
```

---

### üß± Agrupamiento y resumen

```{python}
# Agrupar y resumir
resumen = df.groupby("sexo")["edad"].mean()
print(resumen)
```

---

### üß™ Ejercicios pr√°cticos

1. Lee un archivo CSV de ejemplo y muestra las primeras 5 filas.
2. Filtra todas las personas con edad mayor a 40 y sexo "F".
3. Rellena los valores faltantes de una columna num√©rica con su media.
4. Crea una nueva columna llamada `"es_mayor"` que valga `True` si la persona tiene m√°s de 18 a√±os.
5. Agrupa los datos por `"ocupacion"` y calcula el promedio de `"ingresos"`.

---

### üí° Tip extra: describir datos num√©ricos

```{python}
print(df.describe())
```

---

En la siguiente lecci√≥n podemos cubrir visualizaci√≥n con `matplotlib`, `seaborn` o pasar a integraci√≥n con bases de datos. ¬øCu√°l prefieres? üìäüìàüóÑÔ∏è





---

## üìå Ap√©ndice: Manipulaci√≥n avanzada de datos con `pandas`

Este ap√©ndice incluye t√©cnicas comunes para limpiar y transformar datos m√°s complejos, como cadenas de texto, fechas y datos inconsistentes.

---

### üî§ Limpieza de cadenas de texto (`str`)

`pandas` permite aplicar m√©todos de texto directamente a columnas con `.str`.

```{python}
# Eliminar espacios
df["nombre"] = df["nombre"].str.strip()

# Convertir a min√∫sculas/may√∫sculas
df["email"] = df["email"].str.lower()

# Reemplazar caracteres
df["pais"] = df["pais"].str.replace("M√©x", "M√©xico", regex=False)

# Extraer parte de texto
df["dominio"] = df["email"].str.split("@").str[1]
```

---

### üìÖ Manejo de fechas con `pd.to_datetime`

```{python}
# Convertir columna a tipo fecha
df["fecha_nacimiento"] = pd.to_datetime(df["fecha_nacimiento"])

# Extraer componentes
df["a√±o"] = df["fecha_nacimiento"].dt.year
df["mes"] = df["fecha_nacimiento"].dt.month
df["d√≠a_semana"] = df["fecha_nacimiento"].dt.day_name()
```

üí° Si el formato no es est√°ndar, puedes especificarlo:

```{python}
df["fecha"] = pd.to_datetime(df["fecha"], format="%d/%m/%Y")
```

---

### üîÅ Reemplazo de valores

```{python}
# Reemplazar valores espec√≠ficos
df["sexo"] = df["sexo"].replace({"M": "Masculino", "F": "Femenino"})

# Reemplazar m√∫ltiple con una funci√≥n
df["codigo"] = df["codigo"].apply(lambda x: str(x).zfill(5))  # Rellenar ceros
```

---

### üìä Detectar y eliminar duplicados

```{python}
# Verificar duplicados
print(df.duplicated().sum())

# Eliminar duplicados
df = df.drop_duplicates()
```

---

### üìã Reindexar y renombrar columnas

```{python}
# Renombrar columnas
df = df.rename(columns={"nombre": "Nombre Completo"})

# Reordenar columnas
df = df[["Nombre Completo", "edad", "sexo"]]
```

---

## üß™ Ejercicios extra

1. Limpia una columna de nombres eliminando espacios y pas√°ndola a may√∫sculas.
2. Convierte una columna de fechas y crea nuevas columnas con el a√±o y el d√≠a de la semana.
3. Reemplaza c√≥digos de pa√≠s (`"MX"`, `"AR"`, `"CL"`) por sus nombres completos.
4. Detecta y elimina filas duplicadas de un DataFrame.
5. Ordena las columnas del DataFrame con `"fecha"`, `"nombre"`, `"ingresos"` en ese orden.

---

Estas herramientas te ayudan a preparar los datos para an√°lisis, visualizaci√≥n y modelado de forma s√≥lida üßºüß±üìä





## üß± 20. Programaci√≥n funcional en Python

La programaci√≥n funcional promueve el uso de funciones como entidades de primera clase: se pueden pasar como argumentos, retornarse desde otras funciones y usarse en operaciones como mapeo, filtrado y reducci√≥n.

---

### üîÅ Funci√≥n `map()`

Aplica una funci√≥n a cada elemento de un iterable.

```{python}
numeros = [1, 2, 3, 4]
cuadrados = list(map(lambda x: x**2, numeros))
print(cuadrados)  # [1, 4, 9, 16]
```

---

### üîç Funci√≥n `filter()`

Filtra elementos que cumplen con una condici√≥n booleana.

```{python}
numeros = [10, 15, 20, 25, 30]
pares = list(filter(lambda x: x % 2 == 0, numeros))
print(pares)  # [10, 20, 30]
```

---

### üîÑ Funci√≥n `reduce()` (de `functools`)

Acumula un resultado aplicando una funci√≥n binaria.

```{python}
from functools import reduce

numeros = [1, 2, 3, 4]
producto = reduce(lambda x, y: x * y, numeros)
print(producto)  # 24
```

---

### üß∞ M√≥dulo `functools`

Ofrece herramientas √∫tiles para funciones de orden superior.

```{python}
from functools import partial, lru_cache

# partial: fija argumentos a una funci√≥n
def potencia(base, exponente):
    return base ** exponente

cuadrado = partial(potencia, exponente=2)
print(cuadrado(5))  # 25

# lru_cache: memoriza resultados para acelerar llamadas repetidas
@lru_cache
def fibonacci(n):
    if n <= 1:
        return n
    return fibonacci(n-1) + fibonacci(n-2)

print(fibonacci(30))
```

---

### ‚öôÔ∏è M√≥dulo `operator`

Proporciona funciones predefinidas equivalentes a operadores:

```{python}
import operator

suma = operator.add(3, 5)         # 8
producto = operator.mul(4, 2)     # 8
igualdad = operator.eq(10, 10)    # True
```

Tambi√©n √∫til con `map()` o `reduce()`:

```{python}
from functools import reduce
from operator import mul

numeros = [1, 2, 3, 4]
producto = reduce(mul, numeros)
print(producto)  # 24
```

---

## üß™ Ejercicios pr√°cticos

1. Usa `map()` para convertir una lista de nombres a may√∫sculas.
2. Usa `filter()` para quedarte solo con los n√∫meros mayores a 10.
3. Calcula la suma de una lista con `reduce()` y `operator.add`.
4. Usa `partial()` para crear una funci√≥n `triplicar(x)` que fije `multiplicar(x, 3)`.
5. Crea una funci√≥n recursiva con `lru_cache` para calcular la serie de Fibonacci hasta el n√∫mero 35.

---

¬øTe gustar√≠a seguir con generadores y corutinas (`yield`, `send`) o prefieres que pasemos a visualizaci√≥n de datos o machine learning? üîÅüìäüìà





---

## üìå Ap√©ndice: Generadores y corutinas en Python (`yield`, `send`)

Los **generadores** permiten crear funciones que devuelven valores **uno a uno**, manteniendo su estado entre llamadas. Las **corutinas** ampl√≠an este comportamiento, permitiendo **enviar valores al generador**.

---

### üîÅ Generadores con `yield`

En lugar de `return`, usamos `yield` para **pausar** y **retener el estado**.

```{python}
def contador(maximo):
    n = 1
    while n <= maximo:
        yield n
        n += 1

for numero in contador(5):
    print(numero)
```

Cada vez que se llama al generador, contin√∫a desde el √∫ltimo `yield`.

---

### ‚ö° Comparaci√≥n con listas

```{python}
# Lista: todos los valores en memoria
numeros = [x**2 for x in range(1000000)]

# Generador: uno por uno, sin cargar todo
numeros = (x**2 for x in range(1000000))
```

‚úÖ √ötil para trabajar con datos grandes o flujos infinitos.

---

### üîÑ Corutinas con `send()`

Puedes **enviar datos a un generador desde afuera** usando `send()`. Esto lo convierte en una **corutina**.

```{python}
def eco():
    while True:
        mensaje = yield
        print("Eco:", mensaje)

e = eco()
next(e)            # Inicializa el generador
e.send("Hola")     # Eco: Hola
e.send("Python")   # Eco: Python
```

üß† `yield` act√∫a como **punto de entrada y salida**.

---

### üß™ Ejercicios extra

1. Crea un generador que produzca los primeros `n` m√∫ltiplos de 3.
2. Haz un generador que devuelva letras del abecedario una a una.
3. Crea una corutina que reciba nombres con `send()` y los imprima formateados.
4. Genera una lista infinita de n√∫meros pares con `yield`, y det√©nla al llegar a 50.
5. Usa una expresi√≥n generadora para obtener los cubos de los primeros 100 enteros.

---

Estos conceptos te dan m√°s control sobre **c√≥mo y cu√°ndo se generan los datos**, lo que resulta √∫til en programaci√≥n reactiva, streaming, y estructuras perezosas üîÅ‚öôÔ∏è




---

## üìå Ap√©ndice: Visualizaci√≥n de datos con `matplotlib` y `seaborn`

Las bibliotecas `matplotlib` y `seaborn` son herramientas fundamentales para **crear gr√°ficos** en Python. `matplotlib` es m√°s bajo nivel, mientras que `seaborn` permite visualizaciones estad√≠sticas m√°s f√°cilmente.

---

### üì¶ Cargar librer√≠as

```{python}
import matplotlib.pyplot as plt
import seaborn as sns
import pandas as pd
import numpy as np
```

---

### üìä Gr√°ficos b√°sicos con `matplotlib`

#### üîπ Gr√°fico de l√≠neas

```{python}
x = np.arange(0, 10, 0.1)
y = np.sin(x)

plt.plot(x, y)
plt.title("Seno")
plt.xlabel("x")
plt.ylabel("sin(x)")
plt.grid()
plt.show()
```

#### üîπ Gr√°fico de barras

```{python}
categorias = ["A", "B", "C"]
valores = [5, 3, 7]

plt.bar(categorias, valores)
plt.title("Ventas por categor√≠a")
plt.show()
```

#### üîπ Histograma

```{python}
datos = np.random.randn(1000)

plt.hist(datos, bins=30, color="skyblue")
plt.title("Distribuci√≥n normal")
plt.show()
```

---

### üìà Visualizaci√≥n con `seaborn`

Se construye sobre `matplotlib` y trabaja muy bien con `pandas`.

#### üî∏ Gr√°fico de dispersi√≥n

```{python}
df = sns.load_dataset("tips")
sns.scatterplot(data=df, x="total_bill", y="tip", hue="sex")
plt.title("Cuenta total vs propina")
plt.show()
```

#### üî∏ Boxplot y violinplot

```{python}
sns.boxplot(data=df, x="day", y="total_bill", hue="sex")
plt.title("Distribuci√≥n por d√≠a")
plt.show()

sns.violinplot(data=df, x="day", y="tip", inner="quartile")
plt.show()
```

#### üî∏ Heatmap (mapa de calor)

```{python}
corr = df.corr(numeric_only=True)
sns.heatmap(corr, annot=True, cmap="coolwarm")
plt.title("Matriz de correlaci√≥n")
plt.show()
```

---

### üß™ Ejercicios extra

1. Usa `matplotlib` para graficar la funci√≥n `cos(x)` en el intervalo `[0, 2œÄ]`.
2. Usa `seaborn` para mostrar un histograma de ingresos por sexo usando `df.histplot()`.
3. Crea un gr√°fico de barras con `plt.bar()` mostrando poblaci√≥n por pa√≠s ficticio.
4. Con el dataset `"tips"`, grafica un `boxplot` de `"total_bill"` por `"smoker"`.
5. Genera un heatmap con la correlaci√≥n de variables num√©ricas en cualquier DataFrame.

---

Este ap√©ndice te da las herramientas b√°sicas para **comunicar visualmente tus an√°lisis** üìäüß†  
¬øTe gustar√≠a seguir con gr√°ficos interactivos (`plotly`, `altair`) o preparamos una lecci√≥n de machine learning?



