---
title: "Python Intermedio"
author: "Fernando Alvarado"
date: "2025-04-16"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


## ğŸ§± 12. ComprensiÃ³n profunda de estructuras de datos

Python permite trabajar con estructuras de datos de forma muy flexible y expresiva. AquÃ­ exploraremos **listas y diccionarios por comprensiÃ³n**, el uso **eficiente de `set` y `tuple`**, y tÃ©cnicas para manipular listas y diccionarios de forma avanzada.

---

### ğŸ§  Listas por comprensiÃ³n (List Comprehension)

Permiten crear listas nuevas a partir de otras secuencias con una sintaxis compacta.

```{python}
# Crear una lista de cuadrados del 1 al 10
cuadrados = [x**2 for x in range(1, 11)]
print(cuadrados)

# Filtrar nÃºmeros pares
pares = [x for x in range(20) if x % 2 == 0]
print(pares)
```

---

### ğŸ”‘ Diccionarios por comprensiÃ³n

Igual que las listas, pero usando la sintaxis `{clave:valor for ...}`.

```{python}
# Crear un diccionario de nÃºmero â†’ cuadrado
cuadrados = {x: x**2 for x in range(1, 6)}
print(cuadrados)

# Convertir dos listas en un diccionario
nombres = ["Ana", "Luis", "Marta"]
edades = [25, 30, 22]
personas = {n: e for n, e in zip(nombres, edades)}
print(personas)
```

---

### ğŸ”˜ Uso eficiente de `set` y `tuple`

- `set` elimina duplicados automÃ¡ticamente y permite operaciones como intersecciÃ³n, uniÃ³n, etc.
- `tuple` se usa cuando los datos **no deben cambiar** (inmutabilidad).

```{python}
# Eliminar duplicados
numeros = [1, 2, 2, 3, 4, 4]
unicos = set(numeros)
print(unicos)

# Comparar dos listas
a = {1, 2, 3}
b = {3, 4, 5}
print(a & b)  # IntersecciÃ³n
print(a | b)  # UniÃ³n

# Usar tuplas como claves de diccionario
coords = {(0, 0): "origen", (1, 2): "punto A"}
print(coords[(1, 2)])
```

---

### ğŸ› ï¸ ManipulaciÃ³n avanzada de listas

Algunas tÃ©cnicas Ãºtiles con listas:

```{python}
numeros = [1, 2, 3, 4, 5, 6]

# Rebanado (slicing)
print(numeros[1:4])     # Elementos del Ã­ndice 1 al 3
print(numeros[::-1])    # Lista invertida

# Eliminar elementos por condiciÃ³n
numeros = [x for x in numeros if x % 2 != 0]
print(numeros)

# Map y filter
cuadrados = list(map(lambda x: x**2, [1, 2, 3]))
pares = list(filter(lambda x: x % 2 == 0, range(10)))
```

---

### ğŸ› ï¸ ManipulaciÃ³n avanzada de diccionarios

```{python}
datos = {"a": 1, "b": 2, "c": 3}

# Acceder a claves y valores
for clave, valor in datos.items():
    print(clave, "â†’", valor)

# Invertir claves y valores
inverso = {v: k for k, v in datos.items()}
print(inverso)

# Filtrar claves por condiciÃ³n
filtrado = {k: v for k, v in datos.items() if v % 2 != 0}
print(filtrado)
```

---

## ğŸ§ª Ejercicios prÃ¡cticos

1. Crea una lista por comprensiÃ³n con los nÃºmeros del 1 al 30 que sean mÃºltiplos de 3.
2. Dado un diccionario de alumnos â†’ calificaciÃ³n, crea otro que solo contenga a los aprobados (>= 6).
3. Elimina los duplicados de una lista de frutas y ordÃ©nala alfabÃ©ticamente.
4. Invierte las claves y valores de un diccionario simple.
5. Usando `zip`, convierte dos listas (`nombres`, `notas`) en un diccionario.
6. Crea una lista con las palabras de una oraciÃ³n que tengan mÃ¡s de 4 letras.

---

Â¿Te gustarÃ­a continuar con funciones lambda, uso de `map`/`filter` mÃ¡s a fondo o saltamos a visualizaciÃ³n de datos? ğŸ§®ğŸ“Š


---

## ğŸ“Œ ApÃ©ndice: Funciones `lambda` y funciones de orden superior

Python permite usar **funciones anÃ³nimas** (`lambda`) y pasar funciones como argumentos, lo que da lugar a funciones de **orden superior**. Esto es muy Ãºtil para trabajar con listas, filtros y operaciones funcionales.

---

### âš¡ Funciones `lambda`

Una `lambda` es una funciÃ³n pequeÃ±a y sin nombre, escrita en una sola lÃ­nea.

```{python}
# FunciÃ³n tradicional
def cuadrado(x):
    return x ** 2

# Equivalente lambda
cuadrado_lambda = lambda x: x ** 2

print(cuadrado(4))
print(cuadrado_lambda(4))
```

TambiÃ©n puede recibir varios parÃ¡metros:

```{python}
sumar = lambda a, b: a + b
print(sumar(3, 5))  # 8
```

---

### ğŸ§  Funciones de orden superior

Son funciones que reciben otras funciones como argumento. Ejemplos integrados en Python:

#### `map(function, iterable)`

Aplica la funciÃ³n a cada elemento del iterable.

```{python}
numeros = [1, 2, 3, 4]
cuadrados = list(map(lambda x: x**2, numeros))
print(cuadrados)
```

#### `filter(function, iterable)`

Filtra los elementos para los que la funciÃ³n devuelve `True`.

```{python}
pares = list(filter(lambda x: x % 2 == 0, range(10)))
print(pares)
```

#### `sorted(iterable, key=func)`

Ordena elementos usando una funciÃ³n como criterio.

```{python}
nombres = ["ana", "Luis", "MARTA", "pedro"]
ordenados = sorted(nombres, key=lambda x: x.lower())
print(ordenados)
```

---

### âœ… CuÃ¡ndo usar `lambda` y funciones de orden superior

- Cuando necesitas una funciÃ³n sencilla y **no quieres definirla por separado**.
- Para **operaciones rÃ¡pidas** sobre listas, diccionarios, etc.
- Cuando trabajas con **estructuras funcionales** como `map`, `filter`, `sorted`, `max`, `min`, etc.

---

## ğŸ§ª Ejercicios extra

1. Usa `map` y `lambda` para elevar al cubo todos los elementos de una lista `[1, 2, 3, 4, 5]`.
2. Usa `filter` para conservar solo las palabras que empiezan con vocal en una lista.
3. Ordena una lista de tuplas `(nombre, edad)` por edad usando `lambda`.
4. Crea una lista de funciones lambda que calculen: doble, triple y cuadrado de un nÃºmero, y aplÃ­calas a un mismo valor.

---

Este apÃ©ndice te da herramientas poderosas para escribir cÃ³digo mÃ¡s expresivo y compacto âš™ï¸ğŸ§ 



## ğŸ§± 13. Funciones avanzadas en Python

Las funciones en Python son extremadamente versÃ¡tiles: pueden ser anÃ³nimas (`lambda`), recibir un nÃºmero variable de argumentos, usarse como objetos y decorarse para extender su funcionalidad. AquÃ­ cubrimos lo esencial de su uso avanzado.

---

### âš¡ Funciones anÃ³nimas (`lambda`)

Son funciones sin nombre, Ãºtiles para operaciones rÃ¡pidas y de una sola lÃ­nea.

```{python}
# FunciÃ³n lambda que duplica un nÃºmero
doble = lambda x: x * 2
print(doble(4))  # 8

# Lambda con mÃºltiples argumentos
suma = lambda a, b: a + b
print(suma(2, 3))  # 5
```

---

### âœ³ï¸ Argumentos variables: `*args` y `**kwargs`

- `*args`: permite pasar **cualquier cantidad de argumentos posicionales** (como una tupla).
- `**kwargs`: permite pasar **argumentos con nombre** (como un diccionario).

```{python}
def mostrar_args(*args):
    for arg in args:
        print("Posicional:", arg)

def mostrar_kwargs(**kwargs):
    for clave, valor in kwargs.items():
        print(f"{clave} = {valor}")

mostrar_args(1, 2, 3)
mostrar_kwargs(nombre="Ana", edad=30)
```

Puedes combinar ambos:

```{python}
def ejemplo_completo(a, *args, **kwargs):
    print("a:", a)
    print("args:", args)
    print("kwargs:", kwargs)

ejemplo_completo(1, 2, 3, x=10, y=20)
```

---

### ğŸ§µ Decoradores (`@decorador`)

Un **decorador** es una funciÃ³n que **envuelve a otra** para modificar o extender su comportamiento.

```{python}
def decorador(func):
    def nueva_funcion():
        print("Antes de la funciÃ³n")
        func()
        print("DespuÃ©s de la funciÃ³n")
    return nueva_funcion

@decorador
def saludar():
    print("Hola mundo")

saludar()
```

Esto equivale a:

```{python}
saludar = decorador(saludar_original)
```

---

### ğŸ Closures y funciones como objetos de primera clase

En Python, las funciones son objetos: se pueden **guardar en variables, pasar como argumentos y retornar** desde otras funciones.

#### Closure: funciÃ³n interna que recuerda el contexto de la externa

```{python}
def crear_multiplicador(factor):
    def multiplicar(x):
        return x * factor
    return multiplicar

doble = crear_multiplicador(2)
print(doble(5))  # 10
```

---

## ğŸ§ª Ejercicios prÃ¡cticos

1. Crea una funciÃ³n que reciba `*args` y devuelva la suma de todos los nÃºmeros pasados.
2. Define una funciÃ³n que imprima los valores de cualquier `**kwargs` que reciba.
3. Escribe un decorador que registre (imprima) la hora en la que se ejecuta una funciÃ³n.
4. Crea una funciÃ³n `crear_saludo(nombre)` que devuelva una funciÃ³n que, al llamarla, diga `"Hola <nombre>"`.
5. Crea una lista de funciones lambda que hagan `x+1`, `x+2` y `x+3`, y aplÃ­calas sobre un valor `10`.

---

Â¿Quieres que sigamos con programaciÃ³n funcional, generadores/iteradores, o entramos a visualizaciÃ³n de datos? ğŸ§®ğŸ“ŠğŸ”„



---

## ğŸ“Œ ApÃ©ndice: ProgramaciÃ³n funcional y generadores

Python permite aplicar conceptos de **programaciÃ³n funcional**, como funciones puras, inmutabilidad y composiciÃ³n. TambiÃ©n permite crear **generadores**, funciones que producen valores bajo demanda y consumen poca memoria.

---

### ğŸ§  ProgramaciÃ³n funcional

En este paradigma:

- Las funciones son **ciudadanos de primera clase**
- Se favorece la **inmutabilidad** (no modificar estados)
- Se promueve el uso de funciones puras (sin efectos secundarios)

#### Funciones Ãºtiles: `map()`, `filter()`, `reduce()`

```{python}
# map: aplica una funciÃ³n a cada elemento
numeros = [1, 2, 3, 4]
cuadrados = list(map(lambda x: x**2, numeros))

# filter: selecciona elementos que cumplen una condiciÃ³n
pares = list(filter(lambda x: x % 2 == 0, numeros))

# reduce: acumula un resultado (requiere importar)
from functools import reduce
suma_total = reduce(lambda x, y: x + y, numeros)
```

---

### ğŸ” Generadores

Un **generador** es una funciÃ³n que **produce una secuencia de valores**, uno a la vez, usando `yield` en lugar de `return`.

```{python}
def contador(maximo):
    n = 1
    while n <= maximo:
        yield n
        n += 1

for num in contador(5):
    print(num)
```

âœ… Ventajas:
- Bajo consumo de memoria
- Ãštil para trabajar con datos grandes o secuencias infinitas

---

### ğŸ”„ Expresiones generadoras

MÃ¡s compactas que las funciones generadoras:

```{python}
gen = (x**2 for x in range(5))
for val in gen:
    print(val)
```

---

### ğŸ§ª Ejercicios extra

1. Usa `map()` para convertir una lista de temperaturas en Â°C a Â°F.
2. Usa `filter()` para obtener los nombres que empiezan con vocal de una lista.
3. Escribe una funciÃ³n generadora que produzca los primeros `n` mÃºltiplos de 3.
4. Escribe una expresiÃ³n generadora que produzca los cuadrados de los nÃºmeros del 1 al 10.
5. Crea una funciÃ³n generadora que simule una cuenta regresiva desde `n` hasta 0.

---

Este apÃ©ndice te permite escribir cÃ³digo mÃ¡s **elegante, eficiente y expresivo** ğŸŒ€




## ğŸ§± 14. ProgramaciÃ³n orientada a objetos (OOP) - Parte 2

En esta lecciÃ³n exploramos conceptos avanzados de la ProgramaciÃ³n Orientada a Objetos en Python: **herencia**, **polimorfismo**, **encapsulamiento**, **mÃ©todos mÃ¡gicos**, **propiedades** y **clases abstractas**.

---

### ğŸ§¬ Herencia (repaso breve)

Permite que una clase hija herede atributos y mÃ©todos de una clase padre.

```{python}
class Animal:
    def hablar(self):
        print("Hace un sonido")

class Perro(Animal):
    def hablar(self):
        print("Guau")

p = Perro()
p.hablar()
```

---

### ğŸŒ€ Polimorfismo

Significa que una misma interfaz puede tener mÃºltiples implementaciones.

```{python}
def hacer_hablar(animal):
    animal.hablar()

class Gato:
    def hablar(self):
        print("Miau")

g = Gato()
hacer_hablar(p)  # Guau
hacer_hablar(g)  # Miau
```

---

### ğŸ”’ Encapsulamiento

Controla el acceso a los atributos de un objeto:

- `_atributo`: convenciÃ³n de "protegido"
- `__atributo`: atributo "privado" (name mangling)

```{python}
class Cuenta:
    def __init__(self, saldo):
        self.__saldo = saldo

    def mostrar_saldo(self):
        return self.__saldo

cuenta = Cuenta(1000)
print(cuenta.mostrar_saldo())
# print(cuenta.__saldo)  # Error
```

---

### âœ¨ MÃ©todos mÃ¡gicos

Son funciones especiales con doble guion bajo. Algunos Ãºtiles:

```{python}
class Libro:
    def __init__(self, titulo):
        self.titulo = titulo

    def __str__(self):
        return f"Libro: {self.titulo}"

    def __eq__(self, otro):
        return self.titulo == otro.titulo

    def __len__(self):
        return len(self.titulo)

l1 = Libro("Python")
l2 = Libro("Python")
print(str(l1))      # Libro: Python
print(l1 == l2)     # True
print(len(l1))      # 6
```

---

### âš™ï¸ Propiedades con `@property`

Permite acceder a mÃ©todos como si fueran atributos, Ãºtil para validar datos.

```{python}
class Producto:
    def __init__(self, precio):
        self._precio = precio

    @property
    def precio(self):
        return self._precio

    @precio.setter
    def precio(self, valor):
        if valor >= 0:
            self._precio = valor
        else:
            raise ValueError("Precio no puede ser negativo")

p = Producto(50)
p.precio = 100
print(p.precio)
```

---

### ğŸ§± Clases abstractas y mÃ©todos abstractos

Sirven como base para otras clases. No se pueden instanciar directamente.

```{python}
from abc import ABC, abstractmethod

class Figura(ABC):
    @abstractmethod
    def area(self):
        pass

class Cuadrado(Figura):
    def __init__(self, lado):
        self.lado = lado

    def area(self):
        return self.lado ** 2
```

---

## ğŸ§ª Ejercicios prÃ¡cticos

1. Crea una clase `Vehiculo` con un mÃ©todo `mover()`. Luego crea `Auto` y `Bicicleta` que sobrescriban ese mÃ©todo.
2. Crea una clase `Empleado` con atributo privado `__sueldo` y un mÃ©todo `mostrar_sueldo()`.
3. Implementa la clase `Libro` con `__str__`, `__len__` y `__eq__`.
4. Crea una clase `Rectangulo` con propiedades `base` y `altura` que no permitan valores negativos.
5. Define una clase abstracta `Instrumento` con mÃ©todo abstracto `tocar()`, y luego una clase `Guitarra` que la implemente.

---

Â¿Te gustarÃ­a continuar con estructuras de datos personalizadas, testing o bases de datos con `sqlite3` o `pandas`? ğŸ§ªğŸ“‚ğŸ“‹



## ğŸ§± 15. Manejo de excepciones avanzado

AdemÃ¡s de capturar errores comunes, Python permite crear **excepciones personalizadas** y trabajar con **context managers** para manejar recursos de forma segura y elegante.

---

### ğŸš¨ Excepciones personalizadas

Puedes definir tus propias clases de error heredando de `Exception`. Esto te permite lanzar errores especÃ­ficos y controlarlos claramente.

```{python}
class DivisionPorCeroError(Exception):
    pass

def dividir(a, b):
    if b == 0:
        raise DivisionPorCeroError("No se puede dividir entre cero")
    return a / b

try:
    dividir(10, 0)
except DivisionPorCeroError as e:
    print("Error personalizado:", e)
```

âœ”ï¸ Puedes crear jerarquÃ­as de excepciones si tu aplicaciÃ³n es grande.

---

### ğŸ“¦ Context Managers (`with`, `__enter__`, `__exit__`)

Los context managers **gestionan recursos** (archivos, conexiones, etc.) automÃ¡ticamente.

```{python}
with open("archivo.txt", "w") as f:
    f.write("Hola mundo")
# El archivo se cierra automÃ¡ticamente
```

TambiÃ©n puedes **crear tus propios context managers** con `__enter__` y `__exit__`.

```{python}
class MiContexto:
    def __enter__(self):
        print("Entrando al contexto")
        return self

    def __exit__(self, tipo, valor, traza):
        print("Saliendo del contexto")

with MiContexto():
    print("Dentro del bloque")
```

- `__enter__()` se ejecuta al entrar en el bloque `with`.
- `__exit__()` se ejecuta al salir, y puede recibir informaciÃ³n del error si ocurriÃ³.

---

### ğŸ§  CuÃ¡ndo usar context managers

- Para **abrir y cerrar archivos**
- Para **conectar a bases de datos**
- Para **bloquear recursos** (como hilos o procesos)
- Para **manejar recursos que deben limpiarse** aunque haya errores

---

## ğŸ§ª Ejercicios prÃ¡cticos

1. Crea una excepciÃ³n personalizada `EdadInvalidaError` que se lance si la edad ingresada es negativa.
2. Crea una funciÃ³n `leer_archivo(path)` que devuelva el contenido y capture `FileNotFoundError`.
3. Implementa un context manager llamado `Temporizador` que imprima cuÃ¡ndo se entra y sale del bloque `with`.
4. Crea una clase `ConexionFalsa` con mÃ©todos `__enter__` y `__exit__`, y dentro del contexto imprime "Conectado" y al salir "Desconectado".

---

Â¿Quieres continuar con manejo de archivos CSV/JSON, conexiÃ³n a bases de datos o pruebas automatizadas? ğŸ“‚ğŸ§ªğŸ§¾





## ğŸ§± 16. MÃ³dulos y paquetes en Python

Una de las ventajas de Python es que puedes **organizar tu cÃ³digo en archivos reutilizables** llamados **mÃ³dulos** y agruparlos en **paquetes**. Esto mejora la mantenibilidad, legibilidad y escalabilidad de tus programas.

---

### ğŸ“¦ OrganizaciÃ³n del cÃ³digo en mÃ³dulos

Un **mÃ³dulo** es simplemente un archivo `.py` con funciones, clases o variables que puedes importar en otros archivos.

```python
# archivo: utilidades.py
def saludar(nombre):
    return f"Hola, {nombre}"
```

```python
# archivo: main.py
import utilidades

print(utilidades.saludar("Ana"))
```

TambiÃ©n puedes importar solo lo que necesitas:

```python
from utilidades import saludar
print(saludar("Luis"))
```

---

### ğŸ“ Paquetes y `__init__.py`

Un **paquete** es una carpeta que contiene un archivo `__init__.py`. Ese archivo puede estar vacÃ­o, pero indica que la carpeta es un **paquete importable**.

```text
mi_proyecto/
â”‚
â”œâ”€â”€ paquete/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ modulo1.py
â”‚   â””â”€â”€ modulo2.py
â””â”€â”€ main.py
```

ImportaciÃ³n:

```python
from paquete.modulo1 import funcion_x
```

âœ”ï¸ Puedes colocar funciones comunes en `__init__.py` para importarlas directamente desde el paquete.

---

### ğŸ§­ Importaciones absolutas y relativas

#### ğŸ”¹ ImportaciÃ³n absoluta

Desde la raÃ­z del proyecto:

```python
from paquete.modulo1 import funcion_x
```

#### ğŸ”¸ ImportaciÃ³n relativa

Desde dentro del paquete:

```python
from .modulo1 import funcion_x        # Importar desde mismo nivel
from ..subpaquete.modulo3 import y    # Subir un nivel
```

âœ… Usar importaciones absolutas es mÃ¡s claro en proyectos grandes.  
Las relativas son Ãºtiles cuando tu paquete estÃ¡ aislado del entorno principal.

---

### âš ï¸ Buenas prÃ¡cticas

- Usa nombres descriptivos para mÃ³dulos (`analisis_datos.py`, no `util.py`)
- Agrupa mÃ³dulos por tema dentro de paquetes
- Evita ciclos de importaciÃ³n (mÃ³dulos que se importan entre sÃ­ recursivamente)
- Usa `__all__` en `__init__.py` para controlar quÃ© se expone al importar con `*`

---

## ğŸ§ª Ejercicios prÃ¡cticos

1. Crea un archivo `matematica.py` con funciones `suma(a,b)` y `resta(a,b)`. Luego crea `main.py` para usarlas.
2. Crea un paquete `calculadora` con dos mÃ³dulos: `aritmetica.py` y `geometria.py`. Prueba importar desde ambos.
3. Dentro de `__init__.py`, importa por defecto una funciÃ³n llamada `bienvenida()`.
4. Practica una importaciÃ³n relativa desde un mÃ³dulo `modulo_b.py` hacia `modulo_a.py` dentro del mismo paquete.
5. Crea un proyecto completo con estructura modular y comenta para quÃ© sirve cada archivo.

---

Â¿Quieres seguir con archivos CSV y JSON, bases de datos (`sqlite3`), o desarrollo de entornos virtuales y distribuciÃ³n de paquetes? ğŸ§¾ğŸ—ƒï¸ğŸ“¦





## ğŸ§± 17. Manejo de archivos mÃ¡s allÃ¡ del texto

Python permite trabajar no solo con archivos de texto plano, sino tambiÃ©n con **archivos binarios** y **formatos estructurados** como `CSV` y `JSON`, muy comunes en ciencia de datos, bases de datos y APIs.

---

### ğŸ§Š Lectura y escritura de archivos binarios

Usa los modos `'rb'` (lectura binaria) y `'wb'` (escritura binaria). Es Ãºtil para imÃ¡genes, archivos PDF, audio, etc.

```{python}
# Guardar archivo binario
with open("imagen.jpg", "rb") as archivo_original:
    contenido = archivo_original.read()

with open("copia.jpg", "wb") as copia:
    copia.write(contenido)
```

âœ… Los archivos binarios manejan **bytes**, no texto. No puedes usar `.readline()` ni `.write("texto")`.

---

### ğŸ“‘ Lectura y escritura de CSV

#### Usando el mÃ³dulo `csv`

```{python}
import csv

# Escribir archivo CSV
with open("personas.csv", "w", newline="") as archivo:
    escritor = csv.writer(archivo)
    escritor.writerow(["Nombre", "Edad"])
    escritor.writerow(["Ana", 30])
    escritor.writerow(["Luis", 25])

# Leer archivo CSV
with open("personas.csv", "r") as archivo:
    lector = csv.reader(archivo)
    for fila in lector:
        print(fila)
```

#### Como diccionarios

```{python}
# Leer como diccionario
with open("personas.csv", "r") as archivo:
    lector = csv.DictReader(archivo)
    for fila in lector:
        print(fila["Nombre"], "â†’", fila["Edad"])
```

---

### ğŸ” Lectura y escritura de JSON

`JSON` es un formato muy usado para **intercambio de datos**, especialmente en APIs.

```{python}
import json

datos = {"nombre": "Ana", "edad": 30, "activo": True}

# Escribir archivo JSON
with open("datos.json", "w") as archivo:
    json.dump(datos, archivo, indent=4)

# Leer archivo JSON
with open("datos.json", "r") as archivo:
    cargado = json.load(archivo)
    print(cargado["nombre"])
```

---

### ğŸ§  Â¿CuÃ¡l usar?

| Formato | Ideal para                        |
|---------|-----------------------------------|
| Binario | ImÃ¡genes, audio, video, archivos grandes |
| CSV     | Datos tabulares simples (hojas de cÃ¡lculo, bases de datos) |
| JSON    | Intercambio de datos estructurados (APIs, configuraciÃ³n)  |

---

## ğŸ§ª Ejercicios prÃ¡cticos

1. Copia una imagen `.jpg` usando `rb` y `wb`.
2. Crea un archivo `productos.csv` con columnas `nombre`, `precio`, `stock`. Escribe 3 productos y luego lÃ©elos.
3. Guarda un diccionario en formato `JSON` y recupÃ©ralo desde el archivo.
4. Lee un CSV con `DictReader` e imprime solo los productos cuyo `stock` sea mayor a 10.
5. Transforma un archivo JSON cargado en un diccionario y modifica uno de sus valores antes de volver a guardarlo.

---

Â¿Te gustarÃ­a que lo siguiente sea sobre consumo de APIs con `requests`, conexiÃ³n a bases de datos o grÃ¡ficos con `matplotlib`? ğŸŒğŸ“¡ğŸ“Š




---

## ğŸ“Œ ApÃ©ndice: Consumo de APIs con `requests`

Muchas aplicaciones modernas se comunican con servicios externos a travÃ©s de **APIs (Application Programming Interfaces)**. En Python, el paquete `requests` permite **realizar solicitudes HTTP fÃ¡cilmente**.

---

### ğŸŒ Â¿QuÃ© es una API?

Una API expone datos o funcionalidades mediante URLs. Puedes obtener datos en formatos como `JSON` o `XML`.

Ejemplo:  
`https://api.chucknorris.io/jokes/random` â†’ Devuelve un chiste aleatorio en formato JSON.

---

### âš™ï¸ InstalaciÃ³n del paquete

```bash
pip install requests
```

---

### ğŸ”„ Realizar una solicitud `GET`

```{python}
import requests

url = "https://api.chucknorris.io/jokes/random"
respuesta = requests.get(url)

if respuesta.status_code == 200:
    datos = respuesta.json()
    print("Chiste:", datos["value"])
else:
    print("Error al conectar con la API")
```

- `.get()` â†’ realiza la solicitud
- `.json()` â†’ convierte la respuesta a diccionario
- `.status_code` â†’ revisa si fue exitosa (200 = OK)

---

### ğŸ“¤ Enviar datos con `POST`

```{python}
url = "https://httpbin.org/post"
datos = {"usuario": "Ana", "clave": "123"}

respuesta = requests.post(url, json=datos)
print(respuesta.json())
```

Usamos `.post()` para enviar datos, tÃ­picamente en JSON o formularios.

---

### âš ï¸ Buenas prÃ¡cticas

- Revisa el cÃ³digo de estado antes de acceder a `.json()`
- Usa `try/except` para manejar errores de conexiÃ³n
- No expongas claves API ni credenciales directamente en el cÃ³digo

---

## ğŸ§ª Ejercicios extra

1. Consulta la API de Chuck Norris y guarda 3 chistes distintos en una lista.
2. Consulta la API de PokÃ©mon (`https://pokeapi.co/api/v2/pokemon/ditto`) y extrae su nombre y habilidades.
3. EnvÃ­a un `POST` con tus datos a `https://httpbin.org/post` y observa la respuesta.
4. Usa `try/except` para capturar errores de conexiÃ³n o respuestas invÃ¡lidas.
5. Revisa la documentaciÃ³n de una API pÃºblica de tu interÃ©s y haz tu propia consulta.

---

Este apÃ©ndice te introduce a la base de aplicaciones web modernas y consumo de datos externos ğŸŒğŸ“¡





## ğŸ§± 18. Uso de librerÃ­as estÃ¡ndar y externas

Python cuenta con una extensa **librerÃ­a estÃ¡ndar** y permite instalar **librerÃ­as externas** que extienden su funcionalidad para ciencia de datos, web, automatizaciÃ³n, etc. En esta lecciÃ³n exploramos algunas esenciales.

---

### ğŸ§° LibrerÃ­as estÃ¡ndar Ãºtiles

#### ğŸ” `itertools`: combinatoria y generadores infinitos

```{python}
import itertools

# Producto cartesiano
for a in itertools.product("AB", repeat=2):
    print(a)

# Contador infinito (hasta cierto punto)
for i in itertools.count(10):
    if i > 15:
        break
    print(i)
```

#### ğŸ—ƒï¸ `collections`: estructuras mejoradas

```{python}
from collections import Counter, defaultdict, namedtuple

# Contar frecuencias
contador = Counter("abracadabra")
print(contador)

# Diccionario con valor por defecto
dd = defaultdict(int)
dd["x"] += 1
print(dd)

# Tupla con nombre
Persona = namedtuple("Persona", "nombre edad")
p = Persona("Ana", 30)
print(p.nombre)
```

#### ğŸ•’ `datetime`: fechas y tiempos

```{python}
from datetime import datetime, timedelta

ahora = datetime.now()
print("Ahora:", ahora)

maÃ±ana = ahora + timedelta(days=1)
print("MaÃ±ana:", maÃ±ana)

print("Solo fecha:", ahora.date())
print("Solo hora:", ahora.time())
```

---

### ğŸŒ LibrerÃ­as externas comunes

#### ğŸŒ `requests`: solicitudes HTTP

```{python}
import requests
r = requests.get("https://api.chucknorris.io/jokes/random")
print(r.json()["value"])
```

#### ğŸ“¦ `json`: trabajar con JSON

```{python}
import json

diccionario = {"nombre": "Ana", "edad": 30}
texto = json.dumps(diccionario)
recuperado = json.loads(texto)
print(recuperado)
```

#### ğŸ’» `os`: interacciÃ³n con el sistema operativo

```{python}
import os

print(os.getcwd())            # Directorio actual
print(os.listdir("."))        # Archivos en la carpeta
os.mkdir("nueva_carpeta")     # Crear carpeta
```

#### ğŸ–¥ï¸ `sys`: informaciÃ³n del sistema

```{python}
import sys

print(sys.argv)         # Argumentos de lÃ­nea de comandos
print(sys.version)      # VersiÃ³n de Python
```

---

### ğŸ“¦ Manejo de entornos virtuales

Los entornos virtuales permiten **aislar dependencias de proyectos**.

#### âœ… Usando `venv` (incluido en Python)

```bash
python -m venv mi_entorno
source mi_entorno/bin/activate      # Linux/macOS
mi_entorno\Scripts\activate         # Windows

# Luego puedes instalar paquetes
pip install requests
```

#### ğŸ Usando `conda` (requiere instalaciÃ³n previa)

```bash
conda create -n mi_env python=3.11
conda activate mi_env
conda install requests
```

---

## ğŸ§ª Ejercicios prÃ¡cticos

1. Usa `itertools.product` para generar todas las combinaciones posibles entre las letras `"a", "b", "c"` y los nÃºmeros `1, 2`.
2. Usa `Counter` para contar las letras en `"banana"`.
3. Muestra la fecha de hoy y la fecha de hace 7 dÃ­as usando `datetime`.
4. Crea un archivo JSON desde un diccionario y recupÃ©ralo.
5. Crea un script que imprima el nÃºmero de argumentos recibidos desde lÃ­nea de comandos.
6. Crea un entorno virtual e instala una librerÃ­a como `pandas` o `faker`.

---

Â¿Te gustarÃ­a que prepare una lecciÃ³n final sobre distribuciÃ³n de paquetes (`setup.py`, PyPI), testing o proyectos integradores? ğŸ“¦ğŸ§ªğŸ”




---

## ğŸ“Œ ApÃ©ndice: Testing y depuraciÃ³n en Python

Escribir cÃ³digo sin errores no siempre es posible, pero Python ofrece herramientas para **probar** (`testing`) y **depurar** (`debugging`) nuestros programas de manera profesional y eficiente.

---

### ğŸ§ª Testing: Pruebas automatizadas

#### âœ… Pruebas con `assert`

Para verificar condiciones rÃ¡pidamente durante el desarrollo:

```{python}
def suma(a, b):
    return a + b

assert suma(2, 2) == 4
assert suma(0, 0) == 0
# assert suma(2, 2) == 5  # Levanta AssertionError
```

---

#### ğŸ§ª Pruebas con `unittest`

Framework incorporado en la librerÃ­a estÃ¡ndar:

```{python}
import unittest

def multiplicar(a, b):
    return a * b

class TestMultiplicacion(unittest.TestCase):
    def test_basico(self):
        self.assertEqual(multiplicar(2, 3), 6)

    def test_con_cero(self):
        self.assertEqual(multiplicar(0, 5), 0)

if __name__ == "__main__":
    unittest.main()
```

âœ… Puedes guardar los tests en un archivo separado, como `test_modulo.py`.

---

### ğŸ DepuraciÃ³n (Debugging)

#### ğŸ‘€ Usar `print()` (forma bÃ¡sica)

A veces, imprimir variables clave es suficiente para encontrar errores:

```{python}
def dividir(a, b):
    print("a:", a, "b:", b)
    return a / b
```

---

#### ğŸ§­ Usar `pdb`: el depurador interactivo

```{python}
import pdb

def calcular_area(base, altura):
    pdb.set_trace()
    return base * altura

print(calcular_area(3, 5))
```

Durante la ejecuciÃ³n puedes usar comandos como:
- `n` â†’ siguiente lÃ­nea
- `c` â†’ continuar ejecuciÃ³n
- `p variable` â†’ imprimir variable
- `q` â†’ salir del depurador

---

#### ğŸ§° Usar depuradores en editores como VSCode o PyCharm

- Puedes **poner puntos de ruptura (breakpoints)** sin tocar el cÃ³digo.
- Te permite **inspeccionar valores** en tiempo real.
- Ideal para proyectos grandes o en producciÃ³n.

---

## ğŸ§ª Ejercicios extra

1. Usa `assert` para verificar que una funciÃ³n `es_par(n)` devuelve `True` si `n` es mÃºltiplo de 2.
2. Crea un archivo `test_calculadora.py` con 2 pruebas unitarias: una para `suma(a, b)` y otra para `resta(a, b)`.
3. Inserta `pdb.set_trace()` dentro de una funciÃ³n con error lÃ³gico y explora sus variables paso a paso.
4. Haz que una prueba con `unittest` falle a propÃ³sito y analiza el mensaje de error.
5. Activa el modo debug en tu editor y pon un breakpoint para analizar paso a paso una funciÃ³n.

---

Este apÃ©ndice te ayuda a escribir **cÃ³digo mÃ¡s confiable, robusto y fÃ¡cil de mantener** ğŸ§ªğŸ›





## ğŸ§± 19. Procesamiento y limpieza de datos

Python es ampliamente utilizado en anÃ¡lisis de datos. En esta lecciÃ³n aprenderÃ¡s a usar las librerÃ­as **`pandas`** y **`numpy`** para leer, filtrar y transformar datos de forma eficiente.

---

### ğŸ“¦ Cargar librerÃ­as

```{python}
import pandas as pd
import numpy as np
```

---

### ğŸ“¥ Lectura de datos

`pandas` permite leer archivos CSV, Excel, JSON y mÃ¡s:

```{python}
# Leer archivo CSV
df = pd.read_csv("datos.csv")

# Leer Excel
# df = pd.read_excel("datos.xlsx")

# Vista rÃ¡pida
print(df.head())
print(df.info())
```

---

### ğŸ§¼ Limpieza de datos

#### Identificar y manejar valores faltantes (`NaN`)

```{python}
# Ver si hay valores nulos
print(df.isnull().sum())

# Eliminar filas con NaN
df = df.dropna()

# Rellenar con un valor
df = df.fillna(0)

# Rellenar con la media de la columna
df["columna"] = df["columna"].fillna(df["columna"].mean())
```

---

### ğŸ” Filtrado de datos

```{python}
# Filtrar por condiciÃ³n
adultos = df[df["edad"] >= 18]

# Filtrar mÃºltiples condiciones
hombres_mayores = df[(df["sexo"] == "M") & (df["edad"] > 30)]
```

---

### ğŸ” TransformaciÃ³n de columnas

```{python}
# Crear nueva columna
df["doble_edad"] = df["edad"] * 2

# Aplicar funciÃ³n a una columna
df["nombre_mayuscula"] = df["nombre"].apply(str.upper)

# Usar numpy para transformaciÃ³n
df["log_ingresos"] = np.log(df["ingresos"] + 1)
```

---

### ğŸ§± Agrupamiento y resumen

```{python}
# Agrupar y resumir
resumen = df.groupby("sexo")["edad"].mean()
print(resumen)
```

---

### ğŸ§ª Ejercicios prÃ¡cticos

1. Lee un archivo CSV de ejemplo y muestra las primeras 5 filas.
2. Filtra todas las personas con edad mayor a 40 y sexo "F".
3. Rellena los valores faltantes de una columna numÃ©rica con su media.
4. Crea una nueva columna llamada `"es_mayor"` que valga `True` si la persona tiene mÃ¡s de 18 aÃ±os.
5. Agrupa los datos por `"ocupacion"` y calcula el promedio de `"ingresos"`.

---

### ğŸ’¡ Tip extra: describir datos numÃ©ricos

```{python}
print(df.describe())
```

---

En la siguiente lecciÃ³n podemos cubrir visualizaciÃ³n con `matplotlib`, `seaborn` o pasar a integraciÃ³n con bases de datos. Â¿CuÃ¡l prefieres? ğŸ“ŠğŸ“ˆğŸ—„ï¸





---

## ğŸ“Œ ApÃ©ndice: ManipulaciÃ³n avanzada de datos con `pandas`

Este apÃ©ndice incluye tÃ©cnicas comunes para limpiar y transformar datos mÃ¡s complejos, como cadenas de texto, fechas y datos inconsistentes.

---

### ğŸ”¤ Limpieza de cadenas de texto (`str`)

`pandas` permite aplicar mÃ©todos de texto directamente a columnas con `.str`.

```{python}
# Eliminar espacios
df["nombre"] = df["nombre"].str.strip()

# Convertir a minÃºsculas/mayÃºsculas
df["email"] = df["email"].str.lower()

# Reemplazar caracteres
df["pais"] = df["pais"].str.replace("MÃ©x", "MÃ©xico", regex=False)

# Extraer parte de texto
df["dominio"] = df["email"].str.split("@").str[1]
```

---

### ğŸ“… Manejo de fechas con `pd.to_datetime`

```{python}
# Convertir columna a tipo fecha
df["fecha_nacimiento"] = pd.to_datetime(df["fecha_nacimiento"])

# Extraer componentes
df["aÃ±o"] = df["fecha_nacimiento"].dt.year
df["mes"] = df["fecha_nacimiento"].dt.month
df["dÃ­a_semana"] = df["fecha_nacimiento"].dt.day_name()
```

ğŸ’¡ Si el formato no es estÃ¡ndar, puedes especificarlo:

```{python}
df["fecha"] = pd.to_datetime(df["fecha"], format="%d/%m/%Y")
```

---

### ğŸ” Reemplazo de valores

```{python}
# Reemplazar valores especÃ­ficos
df["sexo"] = df["sexo"].replace({"M": "Masculino", "F": "Femenino"})

# Reemplazar mÃºltiple con una funciÃ³n
df["codigo"] = df["codigo"].apply(lambda x: str(x).zfill(5))  # Rellenar ceros
```

---

### ğŸ“Š Detectar y eliminar duplicados

```{python}
# Verificar duplicados
print(df.duplicated().sum())

# Eliminar duplicados
df = df.drop_duplicates()
```

---

### ğŸ“‹ Reindexar y renombrar columnas

```{python}
# Renombrar columnas
df = df.rename(columns={"nombre": "Nombre Completo"})

# Reordenar columnas
df = df[["Nombre Completo", "edad", "sexo"]]
```

---

## ğŸ§ª Ejercicios extra

1. Limpia una columna de nombres eliminando espacios y pasÃ¡ndola a mayÃºsculas.
2. Convierte una columna de fechas y crea nuevas columnas con el aÃ±o y el dÃ­a de la semana.
3. Reemplaza cÃ³digos de paÃ­s (`"MX"`, `"AR"`, `"CL"`) por sus nombres completos.
4. Detecta y elimina filas duplicadas de un DataFrame.
5. Ordena las columnas del DataFrame con `"fecha"`, `"nombre"`, `"ingresos"` en ese orden.

---

Estas herramientas te ayudan a preparar los datos para anÃ¡lisis, visualizaciÃ³n y modelado de forma sÃ³lida ğŸ§¼ğŸ§±ğŸ“Š





## ğŸ§± 20. ProgramaciÃ³n funcional en Python

La programaciÃ³n funcional promueve el uso de funciones como entidades de primera clase: se pueden pasar como argumentos, retornarse desde otras funciones y usarse en operaciones como mapeo, filtrado y reducciÃ³n.

---

### ğŸ” FunciÃ³n `map()`

Aplica una funciÃ³n a cada elemento de un iterable.

```{python}
numeros = [1, 2, 3, 4]
cuadrados = list(map(lambda x: x**2, numeros))
print(cuadrados)  # [1, 4, 9, 16]
```

---

### ğŸ” FunciÃ³n `filter()`

Filtra elementos que cumplen con una condiciÃ³n booleana.

```{python}
numeros = [10, 15, 20, 25, 30]
pares = list(filter(lambda x: x % 2 == 0, numeros))
print(pares)  # [10, 20, 30]
```

---

### ğŸ”„ FunciÃ³n `reduce()` (de `functools`)

Acumula un resultado aplicando una funciÃ³n binaria.

```{python}
from functools import reduce

numeros = [1, 2, 3, 4]
producto = reduce(lambda x, y: x * y, numeros)
print(producto)  # 24
```

---

### ğŸ§° MÃ³dulo `functools`

Ofrece herramientas Ãºtiles para funciones de orden superior.

```{python}
from functools import partial, lru_cache

# partial: fija argumentos a una funciÃ³n
def potencia(base, exponente):
    return base ** exponente

cuadrado = partial(potencia, exponente=2)
print(cuadrado(5))  # 25

# lru_cache: memoriza resultados para acelerar llamadas repetidas
@lru_cache
def fibonacci(n):
    if n <= 1:
        return n
    return fibonacci(n-1) + fibonacci(n-2)

print(fibonacci(30))
```

---

### âš™ï¸ MÃ³dulo `operator`

Proporciona funciones predefinidas equivalentes a operadores:

```{python}
import operator

suma = operator.add(3, 5)         # 8
producto = operator.mul(4, 2)     # 8
igualdad = operator.eq(10, 10)    # True
```

TambiÃ©n Ãºtil con `map()` o `reduce()`:

```{python}
from functools import reduce
from operator import mul

numeros = [1, 2, 3, 4]
producto = reduce(mul, numeros)
print(producto)  # 24
```

---

## ğŸ§ª Ejercicios prÃ¡cticos

1. Usa `map()` para convertir una lista de nombres a mayÃºsculas.
2. Usa `filter()` para quedarte solo con los nÃºmeros mayores a 10.
3. Calcula la suma de una lista con `reduce()` y `operator.add`.
4. Usa `partial()` para crear una funciÃ³n `triplicar(x)` que fije `multiplicar(x, 3)`.
5. Crea una funciÃ³n recursiva con `lru_cache` para calcular la serie de Fibonacci hasta el nÃºmero 35.

---

Â¿Te gustarÃ­a seguir con generadores y corutinas (`yield`, `send`) o prefieres que pasemos a visualizaciÃ³n de datos o machine learning? ğŸ”ğŸ“ŠğŸ“ˆ





---

## ğŸ“Œ ApÃ©ndice: Generadores y corutinas en Python (`yield`, `send`)

Los **generadores** permiten crear funciones que devuelven valores **uno a uno**, manteniendo su estado entre llamadas. Las **corutinas** amplÃ­an este comportamiento, permitiendo **enviar valores al generador**.

---

### ğŸ” Generadores con `yield`

En lugar de `return`, usamos `yield` para **pausar** y **retener el estado**.

```{python}
def contador(maximo):
    n = 1
    while n <= maximo:
        yield n
        n += 1

for numero in contador(5):
    print(numero)
```

Cada vez que se llama al generador, continÃºa desde el Ãºltimo `yield`.

---

### âš¡ ComparaciÃ³n con listas

```{python}
# Lista: todos los valores en memoria
numeros = [x**2 for x in range(1000000)]

# Generador: uno por uno, sin cargar todo
numeros = (x**2 for x in range(1000000))
```

âœ… Ãštil para trabajar con datos grandes o flujos infinitos.

---

### ğŸ”„ Corutinas con `send()`

Puedes **enviar datos a un generador desde afuera** usando `send()`. Esto lo convierte en una **corutina**.

```{python}
def eco():
    while True:
        mensaje = yield
        print("Eco:", mensaje)

e = eco()
next(e)            # Inicializa el generador
e.send("Hola")     # Eco: Hola
e.send("Python")   # Eco: Python
```

ğŸ§  `yield` actÃºa como **punto de entrada y salida**.

---

### ğŸ§ª Ejercicios extra

1. Crea un generador que produzca los primeros `n` mÃºltiplos de 3.
2. Haz un generador que devuelva letras del abecedario una a una.
3. Crea una corutina que reciba nombres con `send()` y los imprima formateados.
4. Genera una lista infinita de nÃºmeros pares con `yield`, y detÃ©nla al llegar a 50.
5. Usa una expresiÃ³n generadora para obtener los cubos de los primeros 100 enteros.

---

Estos conceptos te dan mÃ¡s control sobre **cÃ³mo y cuÃ¡ndo se generan los datos**, lo que resulta Ãºtil en programaciÃ³n reactiva, streaming, y estructuras perezosas ğŸ”âš™ï¸




---

## ğŸ“Œ ApÃ©ndice: VisualizaciÃ³n de datos con `matplotlib` y `seaborn`

Las bibliotecas `matplotlib` y `seaborn` son herramientas fundamentales para **crear grÃ¡ficos** en Python. `matplotlib` es mÃ¡s bajo nivel, mientras que `seaborn` permite visualizaciones estadÃ­sticas mÃ¡s fÃ¡cilmente.

---

### ğŸ“¦ Cargar librerÃ­as

```{python}
import matplotlib.pyplot as plt
import seaborn as sns
import pandas as pd
import numpy as np
```

---

### ğŸ“Š GrÃ¡ficos bÃ¡sicos con `matplotlib`

#### ğŸ”¹ GrÃ¡fico de lÃ­neas

```{python}
x = np.arange(0, 10, 0.1)
y = np.sin(x)

plt.plot(x, y)
plt.title("Seno")
plt.xlabel("x")
plt.ylabel("sin(x)")
plt.grid()
plt.show()
```

#### ğŸ”¹ GrÃ¡fico de barras

```{python}
categorias = ["A", "B", "C"]
valores = [5, 3, 7]

plt.bar(categorias, valores)
plt.title("Ventas por categorÃ­a")
plt.show()
```

#### ğŸ”¹ Histograma

```{python}
datos = np.random.randn(1000)

plt.hist(datos, bins=30, color="skyblue")
plt.title("DistribuciÃ³n normal")
plt.show()
```

---

### ğŸ“ˆ VisualizaciÃ³n con `seaborn`

Se construye sobre `matplotlib` y trabaja muy bien con `pandas`.

#### ğŸ”¸ GrÃ¡fico de dispersiÃ³n

```{python}
df = sns.load_dataset("tips")
sns.scatterplot(data=df, x="total_bill", y="tip", hue="sex")
plt.title("Cuenta total vs propina")
plt.show()
```

#### ğŸ”¸ Boxplot y violinplot

```{python}
sns.boxplot(data=df, x="day", y="total_bill", hue="sex")
plt.title("DistribuciÃ³n por dÃ­a")
plt.show()

sns.violinplot(data=df, x="day", y="tip", inner="quartile")
plt.show()
```

#### ğŸ”¸ Heatmap (mapa de calor)

```{python}
corr = df.corr(numeric_only=True)
sns.heatmap(corr, annot=True, cmap="coolwarm")
plt.title("Matriz de correlaciÃ³n")
plt.show()
```

---

### ğŸ§ª Ejercicios extra

1. Usa `matplotlib` para graficar la funciÃ³n `cos(x)` en el intervalo `[0, 2Ï€]`.
2. Usa `seaborn` para mostrar un histograma de ingresos por sexo usando `df.histplot()`.
3. Crea un grÃ¡fico de barras con `plt.bar()` mostrando poblaciÃ³n por paÃ­s ficticio.
4. Con el dataset `"tips"`, grafica un `boxplot` de `"total_bill"` por `"smoker"`.
5. Genera un heatmap con la correlaciÃ³n de variables numÃ©ricas en cualquier DataFrame.

---

Este apÃ©ndice te da las herramientas bÃ¡sicas para **comunicar visualmente tus anÃ¡lisis** ğŸ“ŠğŸ§   
Â¿Te gustarÃ­a seguir con grÃ¡ficos interactivos (`plotly`, `altair`) o preparamos una lecciÃ³n de machine learning?



