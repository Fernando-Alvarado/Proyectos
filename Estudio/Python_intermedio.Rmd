---
title: "Python Intermedio"
author: "Fernando Alvarado"
date: "2025-04-16"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


## ğŸ§± 12. ComprensiÃ³n profunda de estructuras de datos

Python permite trabajar con estructuras de datos de forma muy flexible y expresiva. AquÃ­ exploraremos **listas y diccionarios por comprensiÃ³n**, el uso **eficiente de `set` y `tuple`**, y tÃ©cnicas para manipular listas y diccionarios de forma avanzada.

---

### ğŸ§  Listas por comprensiÃ³n (List Comprehension)

Permiten crear listas nuevas a partir de otras secuencias con una sintaxis compacta.

```{python}
# Crear una lista de cuadrados del 1 al 10
cuadrados = [x**2 for x in range(1, 11)]
print(cuadrados)

# Filtrar nÃºmeros pares
pares = [x for x in range(20) if x % 2 == 0]
print(pares)
```

---

### ğŸ”‘ Diccionarios por comprensiÃ³n

Igual que las listas, pero usando la sintaxis `{clave:valor for ...}`.

```{python}
# Crear un diccionario de nÃºmero â†’ cuadrado
cuadrados = {x: x**2 for x in range(1, 6)}
print(cuadrados)

# Convertir dos listas en un diccionario
nombres = ["Ana", "Luis", "Marta"]
edades = [25, 30, 22]
personas = {n: e for n, e in zip(nombres, edades)}
print(personas)
```

---

### ğŸ”˜ Uso eficiente de `set` y `tuple`

- `set` elimina duplicados automÃ¡ticamente y permite operaciones como intersecciÃ³n, uniÃ³n, etc.
- `tuple` se usa cuando los datos **no deben cambiar** (inmutabilidad).

```{python}
# Eliminar duplicados
numeros = [1, 2, 2, 3, 4, 4]
unicos = set(numeros)
print(unicos)

# Comparar dos listas
a = {1, 2, 3}
b = {3, 4, 5}
print(a & b)  # IntersecciÃ³n
print(a | b)  # UniÃ³n

# Usar tuplas como claves de diccionario
coords = {(0, 0): "origen", (1, 2): "punto A"}
print(coords[(1, 2)])
```

---

### ğŸ› ï¸ ManipulaciÃ³n avanzada de listas

Algunas tÃ©cnicas Ãºtiles con listas:

```{python}
numeros = [1, 2, 3, 4, 5, 6]

# Rebanado (slicing)
print(numeros[1:4])     # Elementos del Ã­ndice 1 al 3
print(numeros[::-1])    # Lista invertida

# Eliminar elementos por condiciÃ³n
numeros = [x for x in numeros if x % 2 != 0]
print(numeros)

# Map y filter
cuadrados = list(map(lambda x: x**2, [1, 2, 3]))
pares = list(filter(lambda x: x % 2 == 0, range(10)))
```

---

### ğŸ› ï¸ ManipulaciÃ³n avanzada de diccionarios

```{python}
datos = {"a": 1, "b": 2, "c": 3}

# Acceder a claves y valores
for clave, valor in datos.items():
    print(clave, "â†’", valor)

# Invertir claves y valores
inverso = {v: k for k, v in datos.items()}
print(inverso)

# Filtrar claves por condiciÃ³n
filtrado = {k: v for k, v in datos.items() if v % 2 != 0}
print(filtrado)
```

---

## ğŸ§ª Ejercicios prÃ¡cticos

1. Crea una lista por comprensiÃ³n con los nÃºmeros del 1 al 30 que sean mÃºltiplos de 3.
2. Dado un diccionario de alumnos â†’ calificaciÃ³n, crea otro que solo contenga a los aprobados (>= 6).
3. Elimina los duplicados de una lista de frutas y ordÃ©nala alfabÃ©ticamente.
4. Invierte las claves y valores de un diccionario simple.
5. Usando `zip`, convierte dos listas (`nombres`, `notas`) en un diccionario.
6. Crea una lista con las palabras de una oraciÃ³n que tengan mÃ¡s de 4 letras.

---

Â¿Te gustarÃ­a continuar con funciones lambda, uso de `map`/`filter` mÃ¡s a fondo o saltamos a visualizaciÃ³n de datos? ğŸ§®ğŸ“Š


---

## ğŸ“Œ ApÃ©ndice: Funciones `lambda` y funciones de orden superior

Python permite usar **funciones anÃ³nimas** (`lambda`) y pasar funciones como argumentos, lo que da lugar a funciones de **orden superior**. Esto es muy Ãºtil para trabajar con listas, filtros y operaciones funcionales.

---

### âš¡ Funciones `lambda`

Una `lambda` es una funciÃ³n pequeÃ±a y sin nombre, escrita en una sola lÃ­nea.

```{python}
# FunciÃ³n tradicional
def cuadrado(x):
    return x ** 2

# Equivalente lambda
cuadrado_lambda = lambda x: x ** 2

print(cuadrado(4))
print(cuadrado_lambda(4))
```

TambiÃ©n puede recibir varios parÃ¡metros:

```{python}
sumar = lambda a, b: a + b
print(sumar(3, 5))  # 8
```

---

### ğŸ§  Funciones de orden superior

Son funciones que reciben otras funciones como argumento. Ejemplos integrados en Python:

#### `map(function, iterable)`

Aplica la funciÃ³n a cada elemento del iterable.

```{python}
numeros = [1, 2, 3, 4]
cuadrados = list(map(lambda x: x**2, numeros))
print(cuadrados)
```

#### `filter(function, iterable)`

Filtra los elementos para los que la funciÃ³n devuelve `True`.

```{python}
pares = list(filter(lambda x: x % 2 == 0, range(10)))
print(pares)
```

#### `sorted(iterable, key=func)`

Ordena elementos usando una funciÃ³n como criterio.

```{python}
nombres = ["ana", "Luis", "MARTA", "pedro"]
ordenados = sorted(nombres, key=lambda x: x.lower())
print(ordenados)
```

---

### âœ… CuÃ¡ndo usar `lambda` y funciones de orden superior

- Cuando necesitas una funciÃ³n sencilla y **no quieres definirla por separado**.
- Para **operaciones rÃ¡pidas** sobre listas, diccionarios, etc.
- Cuando trabajas con **estructuras funcionales** como `map`, `filter`, `sorted`, `max`, `min`, etc.

---

## ğŸ§ª Ejercicios extra

1. Usa `map` y `lambda` para elevar al cubo todos los elementos de una lista `[1, 2, 3, 4, 5]`.
2. Usa `filter` para conservar solo las palabras que empiezan con vocal en una lista.
3. Ordena una lista de tuplas `(nombre, edad)` por edad usando `lambda`.
4. Crea una lista de funciones lambda que calculen: doble, triple y cuadrado de un nÃºmero, y aplÃ­calas a un mismo valor.

---

Este apÃ©ndice te da herramientas poderosas para escribir cÃ³digo mÃ¡s expresivo y compacto âš™ï¸ğŸ§ 



## ğŸ§± 13. Funciones avanzadas en Python

Las funciones en Python son extremadamente versÃ¡tiles: pueden ser anÃ³nimas (`lambda`), recibir un nÃºmero variable de argumentos, usarse como objetos y decorarse para extender su funcionalidad. AquÃ­ cubrimos lo esencial de su uso avanzado.

---

### âš¡ Funciones anÃ³nimas (`lambda`)

Son funciones sin nombre, Ãºtiles para operaciones rÃ¡pidas y de una sola lÃ­nea.

```{python}
# FunciÃ³n lambda que duplica un nÃºmero
doble = lambda x: x * 2
print(doble(4))  # 8

# Lambda con mÃºltiples argumentos
suma = lambda a, b: a + b
print(suma(2, 3))  # 5
```

---

### âœ³ï¸ Argumentos variables: `*args` y `**kwargs`

- `*args`: permite pasar **cualquier cantidad de argumentos posicionales** (como una tupla).
- `**kwargs`: permite pasar **argumentos con nombre** (como un diccionario).

```{python}
def mostrar_args(*args):
    for arg in args:
        print("Posicional:", arg)

def mostrar_kwargs(**kwargs):
    for clave, valor in kwargs.items():
        print(f"{clave} = {valor}")

mostrar_args(1, 2, 3)
mostrar_kwargs(nombre="Ana", edad=30)
```

Puedes combinar ambos:

```{python}
def ejemplo_completo(a, *args, **kwargs):
    print("a:", a)
    print("args:", args)
    print("kwargs:", kwargs)

ejemplo_completo(1, 2, 3, x=10, y=20)
```

---

### ğŸ§µ Decoradores (`@decorador`)

Un **decorador** es una funciÃ³n que **envuelve a otra** para modificar o extender su comportamiento.

```{python}
def decorador(func):
    def nueva_funcion():
        print("Antes de la funciÃ³n")
        func()
        print("DespuÃ©s de la funciÃ³n")
    return nueva_funcion

@decorador
def saludar():
    print("Hola mundo")

saludar()
```

Esto equivale a:

```{python}
#saludar = decorador(saludar_original)
```

---

### ğŸ Closures y funciones como objetos de primera clase

En Python, las funciones son objetos: se pueden **guardar en variables, pasar como argumentos y retornar** desde otras funciones.

#### Closure: funciÃ³n interna que recuerda el contexto de la externa

```{python}
def crear_multiplicador(factor):
    def multiplicar(x):
        return x * factor
    return multiplicar

doble = crear_multiplicador(2)
print(doble(5))  # 10
```

---

## ğŸ§ª Ejercicios prÃ¡cticos

1. Crea una funciÃ³n que reciba `*args` y devuelva la suma de todos los nÃºmeros pasados.
2. Define una funciÃ³n que imprima los valores de cualquier `**kwargs` que reciba.
3. Escribe un decorador que registre (imprima) la hora en la que se ejecuta una funciÃ³n.
4. Crea una funciÃ³n `crear_saludo(nombre)` que devuelva una funciÃ³n que, al llamarla, diga `"Hola <nombre>"`.
5. Crea una lista de funciones lambda que hagan `x+1`, `x+2` y `x+3`, y aplÃ­calas sobre un valor `10`.

---

Â¿Quieres que sigamos con programaciÃ³n funcional, generadores/iteradores, o entramos a visualizaciÃ³n de datos? ğŸ§®ğŸ“ŠğŸ”„



---

## ğŸ“Œ ApÃ©ndice: ProgramaciÃ³n funcional y generadores

Python permite aplicar conceptos de **programaciÃ³n funcional**, como funciones puras, inmutabilidad y composiciÃ³n. TambiÃ©n permite crear **generadores**, funciones que producen valores bajo demanda y consumen poca memoria.

---

### ğŸ§  ProgramaciÃ³n funcional

En este paradigma:

- Las funciones son **ciudadanos de primera clase**
- Se favorece la **inmutabilidad** (no modificar estados)
- Se promueve el uso de funciones puras (sin efectos secundarios)

#### Funciones Ãºtiles: `map()`, `filter()`, `reduce()`

```{python}
# map: aplica una funciÃ³n a cada elemento
numeros = [1, 2, 3, 4]
cuadrados = list(map(lambda x: x**2, numeros))

# filter: selecciona elementos que cumplen una condiciÃ³n
pares = list(filter(lambda x: x % 2 == 0, numeros))

# reduce: acumula un resultado (requiere importar)
from functools import reduce
suma_total = reduce(lambda x, y: x + y, numeros)
```

---

### ğŸ” Generadores

Un **generador** es una funciÃ³n que **produce una secuencia de valores**, uno a la vez, usando `yield` en lugar de `return`.

```{python}
def contador(maximo):
    n = 1
    while n <= maximo:
        yield n
        n += 1

for num in contador(5):
    print(num)
```

âœ… Ventajas:
- Bajo consumo de memoria
- Ãštil para trabajar con datos grandes o secuencias infinitas

---

### ğŸ”„ Expresiones generadoras

MÃ¡s compactas que las funciones generadoras:

```{python}
gen = (x**2 for x in range(5))
for val in gen:
    print(val)
```

---

### ğŸ§ª Ejercicios extra

1. Usa `map()` para convertir una lista de temperaturas en Â°C a Â°F.
2. Usa `filter()` para obtener los nombres que empiezan con vocal de una lista.
3. Escribe una funciÃ³n generadora que produzca los primeros `n` mÃºltiplos de 3.
4. Escribe una expresiÃ³n generadora que produzca los cuadrados de los nÃºmeros del 1 al 10.
5. Crea una funciÃ³n generadora que simule una cuenta regresiva desde `n` hasta 0.

---

Este apÃ©ndice te permite escribir cÃ³digo mÃ¡s **elegante, eficiente y expresivo** ğŸŒ€




## ğŸ§± 14. ProgramaciÃ³n orientada a objetos (OOP) - Parte 2

En esta lecciÃ³n exploramos conceptos avanzados de la ProgramaciÃ³n Orientada a Objetos en Python: **herencia**, **polimorfismo**, **encapsulamiento**, **mÃ©todos mÃ¡gicos**, **propiedades** y **clases abstractas**.

---

### ğŸ§¬ Herencia (repaso breve)

Permite que una clase hija herede atributos y mÃ©todos de una clase padre.

```{python}
class Animal:
    def hablar(self):
        print("Hace un sonido")

class Perro(Animal):
    def hablar(self):
        print("Guau")

p = Perro()
p.hablar()
```

---

### ğŸŒ€ Polimorfismo

Significa que una misma interfaz puede tener mÃºltiples implementaciones.

```{python}
def hacer_hablar(animal):
    animal.hablar()

class Gato:
    def hablar(self):
        print("Miau")

g = Gato()
hacer_hablar(p)  # Guau
hacer_hablar(g)  # Miau
```

---

### ğŸ”’ Encapsulamiento

Controla el acceso a los atributos de un objeto:

- `_atributo`: convenciÃ³n de "protegido"
- `__atributo`: atributo "privado" (name mangling)

```{python}
class Cuenta:
    def __init__(self, saldo):
        self.__saldo = saldo

    def mostrar_saldo(self):
        return self.__saldo

cuenta = Cuenta(1000)
print(cuenta.mostrar_saldo())
# print(cuenta.__saldo)  # Error
```

---

### âœ¨ MÃ©todos mÃ¡gicos

Son funciones especiales con doble guion bajo. Algunos Ãºtiles:

```{python}
class Libro:
    def __init__(self, titulo):
        self.titulo = titulo

    def __str__(self):
        return f"Libro: {self.titulo}"

    def __eq__(self, otro):
        return self.titulo == otro.titulo

    def __len__(self):
        return len(self.titulo)

l1 = Libro("Python")
l2 = Libro("Python")
print(str(l1))      # Libro: Python
print(l1 == l2)     # True
print(len(l1))      # 6
```

---

### âš™ï¸ Propiedades con `@property`

Permite acceder a mÃ©todos como si fueran atributos, Ãºtil para validar datos.

```{python}
class Producto:
    def __init__(self, precio):
        self._precio = precio

    @property
    def precio(self):
        return self._precio

    @precio.setter
    def precio(self, valor):
        if valor >= 0:
            self._precio = valor
        else:
            raise ValueError("Precio no puede ser negativo")

p = Producto(50)
p.precio = 100
print(p.precio)
```

---

### ğŸ§± Clases abstractas y mÃ©todos abstractos

Sirven como base para otras clases. No se pueden instanciar directamente.

```{python}
from abc import ABC, abstractmethod

class Figura(ABC):
    @abstractmethod
    def area(self):
        pass

class Cuadrado(Figura):
    def __init__(self, lado):
        self.lado = lado

    def area(self):
        return self.lado ** 2
```

---

## ğŸ§ª Ejercicios prÃ¡cticos

1. Crea una clase `Vehiculo` con un mÃ©todo `mover()`. Luego crea `Auto` y `Bicicleta` que sobrescriban ese mÃ©todo.
2. Crea una clase `Empleado` con atributo privado `__sueldo` y un mÃ©todo `mostrar_sueldo()`.
3. Implementa la clase `Libro` con `__str__`, `__len__` y `__eq__`.
4. Crea una clase `Rectangulo` con propiedades `base` y `altura` que no permitan valores negativos.
5. Define una clase abstracta `Instrumento` con mÃ©todo abstracto `tocar()`, y luego una clase `Guitarra` que la implemente.

---

Â¿Te gustarÃ­a continuar con estructuras de datos personalizadas, testing o bases de datos con `sqlite3` o `pandas`? ğŸ§ªğŸ“‚ğŸ“‹



## ğŸ§± 15. Manejo de excepciones avanzado

AdemÃ¡s de capturar errores comunes, Python permite crear **excepciones personalizadas** y trabajar con **context managers** para manejar recursos de forma segura y elegante.

---

### ğŸš¨ Excepciones personalizadas

Puedes definir tus propias clases de error heredando de `Exception`. Esto te permite lanzar errores especÃ­ficos y controlarlos claramente.

```{python}
class DivisionPorCeroError(Exception):
    pass

def dividir(a, b):
    if b == 0:
        raise DivisionPorCeroError("No se puede dividir entre cero")
    return a / b

try:
    dividir(10, 0)
except DivisionPorCeroError as e:
    print("Error personalizado:", e)
```

âœ”ï¸ Puedes crear jerarquÃ­as de excepciones si tu aplicaciÃ³n es grande.

---

### ğŸ“¦ Context Managers (`with`, `__enter__`, `__exit__`)

Los context managers **gestionan recursos** (archivos, conexiones, etc.) automÃ¡ticamente.

```{python}
with open("archivo.txt", "w") as f:
    f.write("Hola mundo")
# El archivo se cierra automÃ¡ticamente
```

TambiÃ©n puedes **crear tus propios context managers** con `__enter__` y `__exit__`.

```{python}
class MiContexto:
    def __enter__(self):
        print("Entrando al contexto")
        return self

    def __exit__(self, tipo, valor, traza):
        print("Saliendo del contexto")

with MiContexto():
    print("Dentro del bloque")
```

- `__enter__()` se ejecuta al entrar en el bloque `with`.
- `__exit__()` se ejecuta al salir, y puede recibir informaciÃ³n del error si ocurriÃ³.

---

### ğŸ§  CuÃ¡ndo usar context managers

- Para **abrir y cerrar archivos**
- Para **conectar a bases de datos**
- Para **bloquear recursos** (como hilos o procesos)
- Para **manejar recursos que deben limpiarse** aunque haya errores

---

## ğŸ§ª Ejercicios prÃ¡cticos

1. Crea una excepciÃ³n personalizada `EdadInvalidaError` que se lance si la edad ingresada es negativa.
2. Crea una funciÃ³n `leer_archivo(path)` que devuelva el contenido y capture `FileNotFoundError`.
3. Implementa un context manager llamado `Temporizador` que imprima cuÃ¡ndo se entra y sale del bloque `with`.
4. Crea una clase `ConexionFalsa` con mÃ©todos `__enter__` y `__exit__`, y dentro del contexto imprime "Conectado" y al salir "Desconectado".

---

Â¿Quieres continuar con manejo de archivos CSV/JSON, conexiÃ³n a bases de datos o pruebas automatizadas? ğŸ“‚ğŸ§ªğŸ§¾





## ğŸ§± 16. MÃ³dulos y paquetes en Python

Una de las ventajas de Python es que puedes **organizar tu cÃ³digo en archivos reutilizables** llamados **mÃ³dulos** y agruparlos en **paquetes**. Esto mejora la mantenibilidad, legibilidad y escalabilidad de tus programas.

---

### ğŸ“¦ OrganizaciÃ³n del cÃ³digo en mÃ³dulos

Un **mÃ³dulo** es simplemente un archivo `.py` con funciones, clases o variables que puedes importar en otros archivos.

```python
# archivo: utilidades.py
def saludar(nombre):
    return f"Hola, {nombre}"
```

```python
# archivo: main.py
import utilidades

print(utilidades.saludar("Ana"))
```

TambiÃ©n puedes importar solo lo que necesitas:

```python
from utilidades import saludar
print(saludar("Luis"))
```

---

### ğŸ“ Paquetes y `__init__.py`

Un **paquete** es una carpeta que contiene un archivo `__init__.py`. Ese archivo puede estar vacÃ­o, pero indica que la carpeta es un **paquete importable**.

```text
mi_proyecto/
â”‚
â”œâ”€â”€ paquete/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ modulo1.py
â”‚   â””â”€â”€ modulo2.py
â””â”€â”€ main.py
```

ImportaciÃ³n:

```python
from paquete.modulo1 import funcion_x
```

âœ”ï¸ Puedes colocar funciones comunes en `__init__.py` para importarlas directamente desde el paquete.

---

### ğŸ§­ Importaciones absolutas y relativas

#### ğŸ”¹ ImportaciÃ³n absoluta

Desde la raÃ­z del proyecto:

```python
from paquete.modulo1 import funcion_x
```

#### ğŸ”¸ ImportaciÃ³n relativa

Desde dentro del paquete:

```python
from .modulo1 import funcion_x        # Importar desde mismo nivel
from ..subpaquete.modulo3 import y    # Subir un nivel
```

âœ… Usar importaciones absolutas es mÃ¡s claro en proyectos grandes.  
Las relativas son Ãºtiles cuando tu paquete estÃ¡ aislado del entorno principal.

---

### âš ï¸ Buenas prÃ¡cticas

- Usa nombres descriptivos para mÃ³dulos (`analisis_datos.py`, no `util.py`)
- Agrupa mÃ³dulos por tema dentro de paquetes
- Evita ciclos de importaciÃ³n (mÃ³dulos que se importan entre sÃ­ recursivamente)
- Usa `__all__` en `__init__.py` para controlar quÃ© se expone al importar con `*`

---

## ğŸ§ª Ejercicios prÃ¡cticos

1. Crea un archivo `matematica.py` con funciones `suma(a,b)` y `resta(a,b)`. Luego crea `main.py` para usarlas.
2. Crea un paquete `calculadora` con dos mÃ³dulos: `aritmetica.py` y `geometria.py`. Prueba importar desde ambos.
3. Dentro de `__init__.py`, importa por defecto una funciÃ³n llamada `bienvenida()`.
4. Practica una importaciÃ³n relativa desde un mÃ³dulo `modulo_b.py` hacia `modulo_a.py` dentro del mismo paquete.
5. Crea un proyecto completo con estructura modular y comenta para quÃ© sirve cada archivo.

---

Â¿Quieres seguir con archivos CSV y JSON, bases de datos (`sqlite3`), o desarrollo de entornos virtuales y distribuciÃ³n de paquetes? ğŸ§¾ğŸ—ƒï¸ğŸ“¦





## ğŸ§± 17. Manejo de archivos mÃ¡s allÃ¡ del texto

Python permite trabajar no solo con archivos de texto plano, sino tambiÃ©n con **archivos binarios** y **formatos estructurados** como `CSV` y `JSON`, muy comunes en ciencia de datos, bases de datos y APIs.

---

### ğŸ§Š Lectura y escritura de archivos binarios

Usa los modos `'rb'` (lectura binaria) y `'wb'` (escritura binaria). Es Ãºtil para imÃ¡genes, archivos PDF, audio, etc.

```{python}
# Guardar archivo binario
#with open("imagen.jpg", "rb") as archivo_original:
#    contenido = archivo_original.read()

#with open("copia.jpg", "wb") as copia:
#    copia.write(contenido)
```

âœ… Los archivos binarios manejan **bytes**, no texto. No puedes usar `.readline()` ni `.write("texto")`.

---

### ğŸ“‘ Lectura y escritura de CSV

#### Usando el mÃ³dulo `csv`

```{python}
import csv

# Escribir archivo CSV
with open("personas.csv", "w", newline="") as archivo:
    escritor = csv.writer(archivo)
    escritor.writerow(["Nombre", "Edad"])
    escritor.writerow(["Ana", 30])
    escritor.writerow(["Luis", 25])

# Leer archivo CSV
with open("personas.csv", "r") as archivo:
    lector = csv.reader(archivo)
    for fila in lector:
        print(fila)
```

#### Como diccionarios

```{python}
# Leer como diccionario
with open("personas.csv", "r") as archivo:
    lector = csv.DictReader(archivo)
    for fila in lector:
        print(fila["Nombre"], "â†’", fila["Edad"])
```

---

### ğŸ” Lectura y escritura de JSON

`JSON` es un formato muy usado para **intercambio de datos**, especialmente en APIs.

```{python}
import json

datos = {"nombre": "Ana", "edad": 30, "activo": True}

# Escribir archivo JSON
with open("datos.json", "w") as archivo:
    json.dump(datos, archivo, indent=4)

# Leer archivo JSON
with open("datos.json", "r") as archivo:
    cargado = json.load(archivo)
    print(cargado["nombre"])
```

---

### ğŸ§  Â¿CuÃ¡l usar?

| Formato | Ideal para                        |
|---------|-----------------------------------|
| Binario | ImÃ¡genes, audio, video, archivos grandes |
| CSV     | Datos tabulares simples (hojas de cÃ¡lculo, bases de datos) |
| JSON    | Intercambio de datos estructurados (APIs, configuraciÃ³n)  |

---

## ğŸ§ª Ejercicios prÃ¡cticos

1. Copia una imagen `.jpg` usando `rb` y `wb`.
2. Crea un archivo `productos.csv` con columnas `nombre`, `precio`, `stock`. Escribe 3 productos y luego lÃ©elos.
3. Guarda un diccionario en formato `JSON` y recupÃ©ralo desde el archivo.
4. Lee un CSV con `DictReader` e imprime solo los productos cuyo `stock` sea mayor a 10.
5. Transforma un archivo JSON cargado en un diccionario y modifica uno de sus valores antes de volver a guardarlo.

---

Â¿Te gustarÃ­a que lo siguiente sea sobre consumo de APIs con `requests`, conexiÃ³n a bases de datos o grÃ¡ficos con `matplotlib`? ğŸŒğŸ“¡ğŸ“Š




---

## ğŸ“Œ ApÃ©ndice: Consumo de APIs con `requests`

Muchas aplicaciones modernas se comunican con servicios externos a travÃ©s de **APIs (Application Programming Interfaces)**. En Python, el paquete `requests` permite **realizar solicitudes HTTP fÃ¡cilmente**.

---

### ğŸŒ Â¿QuÃ© es una API?

Una API expone datos o funcionalidades mediante URLs. Puedes obtener datos en formatos como `JSON` o `XML`.

Ejemplo:  
`https://api.chucknorris.io/jokes/random` â†’ Devuelve un chiste aleatorio en formato JSON.

---

### âš™ï¸ InstalaciÃ³n del paquete

```bash
#pip install requests
```

---

### ğŸ”„ Realizar una solicitud `GET`

```{python}
#import requests

#url = "https://api.chucknorris.io/jokes/random"
#respuesta = requests.get(url)

#if respuesta.status_code == 200:
#    datos = respuesta.json()
#    print("Chiste:", datos["value"])
#else:
#    print("Error al conectar con la API")
```

- `.get()` â†’ realiza la solicitud
- `.json()` â†’ convierte la respuesta a diccionario
- `.status_code` â†’ revisa si fue exitosa (200 = OK)

---

### ğŸ“¤ Enviar datos con `POST`

```{python}
#url = "https://httpbin.org/post"
#datos = {"usuario": "Ana", "clave": "123"}

#respuesta = requests.post(url, json=datos)
#print(respuesta.json())
```

Usamos `.post()` para enviar datos, tÃ­picamente en JSON o formularios.

---

### âš ï¸ Buenas prÃ¡cticas

- Revisa el cÃ³digo de estado antes de acceder a `.json()`
- Usa `try/except` para manejar errores de conexiÃ³n
- No expongas claves API ni credenciales directamente en el cÃ³digo

---

## ğŸ§ª Ejercicios extra

1. Consulta la API de Chuck Norris y guarda 3 chistes distintos en una lista.
2. Consulta la API de PokÃ©mon (`https://pokeapi.co/api/v2/pokemon/ditto`) y extrae su nombre y habilidades.
3. EnvÃ­a un `POST` con tus datos a `https://httpbin.org/post` y observa la respuesta.
4. Usa `try/except` para capturar errores de conexiÃ³n o respuestas invÃ¡lidas.
5. Revisa la documentaciÃ³n de una API pÃºblica de tu interÃ©s y haz tu propia consulta.

---

Este apÃ©ndice te introduce a la base de aplicaciones web modernas y consumo de datos externos ğŸŒğŸ“¡





## ğŸ§± 18. Uso de librerÃ­as estÃ¡ndar y externas

Python cuenta con una extensa **librerÃ­a estÃ¡ndar** y permite instalar **librerÃ­as externas** que extienden su funcionalidad para ciencia de datos, web, automatizaciÃ³n, etc. En esta lecciÃ³n exploramos algunas esenciales.

---

### ğŸ§° LibrerÃ­as estÃ¡ndar Ãºtiles

#### ğŸ” `itertools`: combinatoria y generadores infinitos

```{python}
import itertools

# Producto cartesiano
for a in itertools.product("AB", repeat=2):
    print(a)

# Contador infinito (hasta cierto punto)
for i in itertools.count(10):
    if i > 15:
        break
    print(i)
```

#### ğŸ—ƒï¸ `collections`: estructuras mejoradas

```{python}
from collections import Counter, defaultdict, namedtuple

# Contar frecuencias
contador = Counter("abracadabra")
print(contador)

# Diccionario con valor por defecto
dd = defaultdict(int)
dd["x"] += 1
print(dd)

# Tupla con nombre
Persona = namedtuple("Persona", "nombre edad")
p = Persona("Ana", 30)
print(p.nombre)
```

#### ğŸ•’ `datetime`: fechas y tiempos

```{python}
from datetime import datetime, timedelta

ahora = datetime.now()
print("Ahora:", ahora)

maÃ±ana = ahora + timedelta(days=1)
print("MaÃ±ana:", maÃ±ana)

print("Solo fecha:", ahora.date())
print("Solo hora:", ahora.time())
```

---

### ğŸŒ LibrerÃ­as externas comunes

#### ğŸŒ `requests`: solicitudes HTTP

```{python}
#import requests
#r = requests.get("https://api.chucknorris.io/jokes/random")
#print(r.json()["value"])
```

#### ğŸ“¦ `json`: trabajar con JSON

```{python}
import json

diccionario = {"nombre": "Ana", "edad": 30}
texto = json.dumps(diccionario)
recuperado = json.loads(texto)
print(recuperado)
```

#### ğŸ’» `os`: interacciÃ³n con el sistema operativo

```{python}
import os

print(os.getcwd())            # Directorio actual
print(os.listdir("."))        # Archivos en la carpeta
os.mkdir("nueva_carpeta")     # Crear carpeta
```

#### ğŸ–¥ï¸ `sys`: informaciÃ³n del sistema

```{python}
import sys

print(sys.argv)         # Argumentos de lÃ­nea de comandos
print(sys.version)      # VersiÃ³n de Python
```

---

### ğŸ“¦ Manejo de entornos virtuales

Los entornos virtuales permiten **aislar dependencias de proyectos**.

#### âœ… Usando `venv` (incluido en Python)

```bash
python -m venv mi_entorno
source mi_entorno/bin/activate      # Linux/macOS
mi_entorno\Scripts\activate         # Windows

# Luego puedes instalar paquetes
pip install requests
```

#### ğŸ Usando `conda` (requiere instalaciÃ³n previa)

```bash
conda create -n mi_env python=3.11
conda activate mi_env
conda install requests
```

---

## ğŸ§ª Ejercicios prÃ¡cticos

1. Usa `itertools.product` para generar todas las combinaciones posibles entre las letras `"a", "b", "c"` y los nÃºmeros `1, 2`.
2. Usa `Counter` para contar las letras en `"banana"`.
3. Muestra la fecha de hoy y la fecha de hace 7 dÃ­as usando `datetime`.
4. Crea un archivo JSON desde un diccionario y recupÃ©ralo.
5. Crea un script que imprima el nÃºmero de argumentos recibidos desde lÃ­nea de comandos.
6. Crea un entorno virtual e instala una librerÃ­a como `pandas` o `faker`.

---

Â¿Te gustarÃ­a que prepare una lecciÃ³n final sobre distribuciÃ³n de paquetes (`setup.py`, PyPI), testing o proyectos integradores? ğŸ“¦ğŸ§ªğŸ”




---

## ğŸ“Œ ApÃ©ndice: Testing y depuraciÃ³n en Python

Escribir cÃ³digo sin errores no siempre es posible, pero Python ofrece herramientas para **probar** (`testing`) y **depurar** (`debugging`) nuestros programas de manera profesional y eficiente.

---

### ğŸ§ª Testing: Pruebas automatizadas

#### âœ… Pruebas con `assert`

Para verificar condiciones rÃ¡pidamente durante el desarrollo:

```{python}
def suma(a, b):
    return a + b

assert suma(2, 2) == 4
assert suma(0, 0) == 0
# assert suma(2, 2) == 5  # Levanta AssertionError
```

---

#### ğŸ§ª Pruebas con `unittest`

Framework incorporado en la librerÃ­a estÃ¡ndar:

```{python}
#import unittest

#def multiplicar(a, b):
 #   return a * b

#class TestMultiplicacion(unittest.TestCase):
#    def test_basico(self):
#        self.assertEqual(multiplicar(2, 3), 6)

#    def test_con_cero(self):
#        self.assertEqual(multiplicar(0, 5), 0)

#if __name__ == "__main__":
#    unittest.main()
```

âœ… Puedes guardar los tests en un archivo separado, como `test_modulo.py`.

---

### ğŸ DepuraciÃ³n (Debugging)

#### ğŸ‘€ Usar `print()` (forma bÃ¡sica)

A veces, imprimir variables clave es suficiente para encontrar errores:

```{python}
def dividir(a, b):
    print("a:", a, "b:", b)
    return a / b
```

---

#### ğŸ§­ Usar `pdb`: el depurador interactivo

```{python}
#import pdb

#def calcular_area(base, altura):
#    pdb.set_trace()
#    return base * altura

#print(calcular_area(3, 5))
```

Durante la ejecuciÃ³n puedes usar comandos como:
- `n` â†’ siguiente lÃ­nea
- `c` â†’ continuar ejecuciÃ³n
- `p variable` â†’ imprimir variable
- `q` â†’ salir del depurador

---

#### ğŸ§° Usar depuradores en editores como VSCode o PyCharm

- Puedes **poner puntos de ruptura (breakpoints)** sin tocar el cÃ³digo.
- Te permite **inspeccionar valores** en tiempo real.
- Ideal para proyectos grandes o en producciÃ³n.

---

## ğŸ§ª Ejercicios extra

1. Usa `assert` para verificar que una funciÃ³n `es_par(n)` devuelve `True` si `n` es mÃºltiplo de 2.
2. Crea un archivo `test_calculadora.py` con 2 pruebas unitarias: una para `suma(a, b)` y otra para `resta(a, b)`.
3. Inserta `pdb.set_trace()` dentro de una funciÃ³n con error lÃ³gico y explora sus variables paso a paso.
4. Haz que una prueba con `unittest` falle a propÃ³sito y analiza el mensaje de error.
5. Activa el modo debug en tu editor y pon un breakpoint para analizar paso a paso una funciÃ³n.

---

Este apÃ©ndice te ayuda a escribir **cÃ³digo mÃ¡s confiable, robusto y fÃ¡cil de mantener** ğŸ§ªğŸ›





## ğŸ§± 19. Procesamiento y limpieza de datos

Python es ampliamente utilizado en anÃ¡lisis de datos. En esta lecciÃ³n aprenderÃ¡s a usar las librerÃ­as **`pandas`** y **`numpy`** para leer, filtrar y transformar datos de forma eficiente.

---

### ğŸ“¦ Cargar librerÃ­as

```{python}
#import pandas as pd
#import numpy as np
```

---

### ğŸ“¥ Lectura de datos

`pandas` permite leer archivos CSV, Excel, JSON y mÃ¡s:

```{python}
# Leer archivo CSV
#df = pd.read_csv("datos.csv")

# Leer Excel
# df = pd.read_excel("datos.xlsx")

# Vista rÃ¡pida
#print(df.head())
#print(df.info())
```

---

### ğŸ§¼ Limpieza de datos

#### Identificar y manejar valores faltantes (`NaN`)

```{python}
# Ver si hay valores nulos
#print(df.isnull().sum())

# Eliminar filas con NaN
#df = df.dropna()

# Rellenar con un valor
#df = df.fillna(0)

# Rellenar con la media de la columna
#df["columna"] = df["columna"].fillna(df["columna"].mean())
```

---

### ğŸ” Filtrado de datos

```{python}
# Filtrar por condiciÃ³n
#adultos = df[df["edad"] >= 18]

# Filtrar mÃºltiples condiciones
#hombres_mayores = df[(df["sexo"] == "M") & (df["edad"] > 30)]
```

---

### ğŸ” TransformaciÃ³n de columnas

```{python}
# Crear nueva columna
#f["doble_edad"] = df["edad"] * 2

# Aplicar funciÃ³n a una columna
#df["nombre_mayuscula"] = df["nombre"].apply(str.upper)

# Usar numpy para transformaciÃ³n
#df["log_ingresos"] = np.log(df["ingresos"] + 1)
```

---

### ğŸ§± Agrupamiento y resumen

```{python}
# Agrupar y resumir
#resumen = df.groupby("sexo")["edad"].mean()
#print(resumen)
```

---

### ğŸ§ª Ejercicios prÃ¡cticos

1. Lee un archivo CSV de ejemplo y muestra las primeras 5 filas.
2. Filtra todas las personas con edad mayor a 40 y sexo "F".
3. Rellena los valores faltantes de una columna numÃ©rica con su media.
4. Crea una nueva columna llamada `"es_mayor"` que valga `True` si la persona tiene mÃ¡s de 18 aÃ±os.
5. Agrupa los datos por `"ocupacion"` y calcula el promedio de `"ingresos"`.

---

### ğŸ’¡ Tip extra: describir datos numÃ©ricos

```{python}
#print(df.describe())
```

---

En la siguiente lecciÃ³n podemos cubrir visualizaciÃ³n con `matplotlib`, `seaborn` o pasar a integraciÃ³n con bases de datos. Â¿CuÃ¡l prefieres? ğŸ“ŠğŸ“ˆğŸ—„ï¸





---

## ğŸ“Œ ApÃ©ndice: ManipulaciÃ³n avanzada de datos con `pandas`

Este apÃ©ndice incluye tÃ©cnicas comunes para limpiar y transformar datos mÃ¡s complejos, como cadenas de texto, fechas y datos inconsistentes.

---

### ğŸ”¤ Limpieza de cadenas de texto (`str`)

`pandas` permite aplicar mÃ©todos de texto directamente a columnas con `.str`.

```{python}
# Eliminar espacios
# df["nombre"] = df["nombre"].str.strip()

# Convertir a minÃºsculas/mayÃºsculas
# df["email"] = df["email"].str.lower()

# Reemplazar caracteres
# df["pais"] = df["pais"].str.replace("MÃ©x", "MÃ©xico", regex=False)

# Extraer parte de texto
# df["dominio"] = df["email"].str.split("@").str[1]
```

---

### ğŸ“… Manejo de fechas con `pd.to_datetime`

```{python}
# Convertir columna a tipo fecha
# df["fecha_nacimiento"] = pd.to_datetime(df["fecha_nacimiento"])

# Extraer componentes
# df["aÃ±o"] = df["fecha_nacimiento"].dt.year
# df["mes"] = df["fecha_nacimiento"].dt.month
# df["dÃ­a_semana"] = df["fecha_nacimiento"].dt.day_name()
```

ğŸ’¡ Si el formato no es estÃ¡ndar, puedes especificarlo:

```{python}
#df["fecha"] = pd.to_datetime(df["fecha"], format="%d/%m/%Y")
```

---

### ğŸ” Reemplazo de valores

```{python}
# Reemplazar valores especÃ­ficos
# df["sexo"] = df["sexo"].replace({"M": "Masculino", "F": "Femenino"})

# Reemplazar mÃºltiple con una funciÃ³n
# df["codigo"] = df["codigo"].apply(lambda x: str(x).zfill(5))  # Rellenar ceros
```

---

### ğŸ“Š Detectar y eliminar duplicados

```{python}
# Verificar duplicados
# print(df.duplicated().sum())

# Eliminar duplicados
# df = df.drop_duplicates()

```

---

### ğŸ“‹ Reindexar y renombrar columnas

```{python}
# Renombrar columnas
#df = df.rename(columns={"nombre": "Nombre Completo"})

# Reordenar columnas
#df = df[["Nombre Completo", "edad", "sexo"]]
```

---

## ğŸ§ª Ejercicios extra

1. Limpia una columna de nombres eliminando espacios y pasÃ¡ndola a mayÃºsculas.
2. Convierte una columna de fechas y crea nuevas columnas con el aÃ±o y el dÃ­a de la semana.
3. Reemplaza cÃ³digos de paÃ­s (`"MX"`, `"AR"`, `"CL"`) por sus nombres completos.
4. Detecta y elimina filas duplicadas de un DataFrame.
5. Ordena las columnas del DataFrame con `"fecha"`, `"nombre"`, `"ingresos"` en ese orden.

---

Estas herramientas te ayudan a preparar los datos para anÃ¡lisis, visualizaciÃ³n y modelado de forma sÃ³lida ğŸ§¼ğŸ§±ğŸ“Š





## ğŸ§± 20. ProgramaciÃ³n funcional en Python

La programaciÃ³n funcional promueve el uso de funciones como entidades de primera clase: se pueden pasar como argumentos, retornarse desde otras funciones y usarse en operaciones como mapeo, filtrado y reducciÃ³n.

---

### ğŸ” FunciÃ³n `map()`

Aplica una funciÃ³n a cada elemento de un iterable.

```{python}
#numeros = [1, 2, 3, 4]
#cuadrados = list(map(lambda x: x**2, numeros))
#print(cuadrados)  # [1, 4, 9, 16]
```

---

### ğŸ” FunciÃ³n `filter()`

Filtra elementos que cumplen con una condiciÃ³n booleana.

```{python}
#numeros = [10, 15, 20, 25, 30]
#pares = list(filter(lambda x: x % 2 == 0, numeros))
#print(pares)  # [10, 20, 30] 
```

---

### ğŸ”„ FunciÃ³n `reduce()` (de `functools`)

Acumula un resultado aplicando una funciÃ³n binaria.

```{python}
# from functools import reduce

# numeros = [1, 2, 3, 4]
# producto = reduce(lambda x, y: x * y, numeros)
# print(producto)  # 24

```

---

### ğŸ§° MÃ³dulo `functools`

Ofrece herramientas Ãºtiles para funciones de orden superior.

```{python}
# from functools import partial, lru_cache

# partial: fija argumentos a una funciÃ³n
# def potencia(base, exponente):
#     return base ** exponente

# cuadrado = partial(potencia, exponente=2)
# print(cuadrado(5))  # 25

# lru_cache: memoriza resultados para acelerar llamadas repetidas
# @lru_cache
# def fibonacci(n):
#     if n <= 1:
#         return n
#     return fibonacci(n-1) + fibonacci(n-2)

# print(fibonacci(30))

```

---

### âš™ï¸ MÃ³dulo `operator`

Proporciona funciones predefinidas equivalentes a operadores:

```{python}
# import operator

# suma = operator.add(3, 5)         # 8
# producto = operator.mul(4, 2)     # 8
# igualdad = operator.eq(10, 10)    # True

```

TambiÃ©n Ãºtil con `map()` o `reduce()`:

```{python}
# from functools import reduce
# from operator import mul

# numeros = [1, 2, 3, 4]
# producto = reduce(mul, numeros)
# print(producto)  # 24

```

---

## ğŸ§ª Ejercicios prÃ¡cticos

1. Usa `map()` para convertir una lista de nombres a mayÃºsculas.
2. Usa `filter()` para quedarte solo con los nÃºmeros mayores a 10.
3. Calcula la suma de una lista con `reduce()` y `operator.add`.
4. Usa `partial()` para crear una funciÃ³n `triplicar(x)` que fije `multiplicar(x, 3)`.
5. Crea una funciÃ³n recursiva con `lru_cache` para calcular la serie de Fibonacci hasta el nÃºmero 35.

---

Â¿Te gustarÃ­a seguir con generadores y corutinas (`yield`, `send`) o prefieres que pasemos a visualizaciÃ³n de datos o machine learning? ğŸ”ğŸ“ŠğŸ“ˆ





---

## ğŸ“Œ ApÃ©ndice: Generadores y corutinas en Python (`yield`, `send`)

Los **generadores** permiten crear funciones que devuelven valores **uno a uno**, manteniendo su estado entre llamadas. Las **corutinas** amplÃ­an este comportamiento, permitiendo **enviar valores al generador**.

---

### ğŸ” Generadores con `yield`

En lugar de `return`, usamos `yield` para **pausar** y **retener el estado**.

```{python}
# def contador(maximo):
#     n = 1
#     while n <= maximo:
#         yield n
#         n += 1

# for numero in contador(5):
#     print(numero)

```

Cada vez que se llama al generador, continÃºa desde el Ãºltimo `yield`.

---

### âš¡ ComparaciÃ³n con listas

```{python}
# Lista: todos los valores en memoria
# numeros = [x**2 for x in range(1000000)]

# Generador: uno por uno, sin cargar todo
# numeros = (x**2 for x in range(1000000))

```

âœ… Ãštil para trabajar con datos grandes o flujos infinitos.

---

### ğŸ”„ Corutinas con `send()`

Puedes **enviar datos a un generador desde afuera** usando `send()`. Esto lo convierte en una **corutina**.

```{python}
# def eco():
#     while True:
#         mensaje = yield
#         print("Eco:", mensaje)

# e = eco()
# next(e)            # Inicializa el generador
# e.send("Hola")     # Eco: Hola
# e.send("Python")   # Eco: Python

```

ğŸ§  `yield` actÃºa como **punto de entrada y salida**.

---

### ğŸ§ª Ejercicios extra

1. Crea un generador que produzca los primeros `n` mÃºltiplos de 3.
2. Haz un generador que devuelva letras del abecedario una a una.
3. Crea una corutina que reciba nombres con `send()` y los imprima formateados.
4. Genera una lista infinita de nÃºmeros pares con `yield`, y detÃ©nla al llegar a 50.
5. Usa una expresiÃ³n generadora para obtener los cubos de los primeros 100 enteros.

---

Estos conceptos te dan mÃ¡s control sobre **cÃ³mo y cuÃ¡ndo se generan los datos**, lo que resulta Ãºtil en programaciÃ³n reactiva, streaming, y estructuras perezosas ğŸ”âš™ï¸




---

## ğŸ“Œ ApÃ©ndice: VisualizaciÃ³n de datos con `matplotlib` y `seaborn`

Las bibliotecas `matplotlib` y `seaborn` son herramientas fundamentales para **crear grÃ¡ficos** en Python. `matplotlib` es mÃ¡s bajo nivel, mientras que `seaborn` permite visualizaciones estadÃ­sticas mÃ¡s fÃ¡cilmente.

---

### ğŸ“¦ Cargar librerÃ­as

```{python}
# import matplotlib.pyplot as plt
# import seaborn as sns
# import pandas as pd
# import numpy as np
```

---

### ğŸ“Š GrÃ¡ficos bÃ¡sicos con `matplotlib`

#### ğŸ”¹ GrÃ¡fico de lÃ­neas

```{python}
# x = np.arange(0, 10, 0.1)
# y = np.sin(x)

# plt.plot(x, y)
# plt.title("Seno")
# plt.xlabel("x")
# plt.ylabel("sin(x)")
# plt.grid()
# plt.show()

```

#### ğŸ”¹ GrÃ¡fico de barras

```{python}
# categorias = ["A", "B", "C"]
# valores = [5, 3, 7]

# plt.bar(categorias, valores)
# plt.title("Ventas por categorÃ­a")
# plt.show()

```

#### ğŸ”¹ Histograma

```{python}
# datos = np.random.randn(1000)

# plt.hist(datos, bins=30, color="skyblue")
# plt.title("DistribuciÃ³n normal")
# plt.show()

```

---

### ğŸ“ˆ VisualizaciÃ³n con `seaborn`

Se construye sobre `matplotlib` y trabaja muy bien con `pandas`.

#### ğŸ”¸ GrÃ¡fico de dispersiÃ³n

```{python}
# df = sns.load_dataset("tips")
# sns.scatterplot(data=df, x="total_bill", y="tip", hue="sex")
# plt.title("Cuenta total vs propina")
# plt.show()

```

#### ğŸ”¸ Boxplot y violinplot

```{python}
# sns.boxplot(data=df, x="day", y="total_bill", hue="sex")
# plt.title("DistribuciÃ³n por dÃ­a")
# plt.show()

# sns.violinplot(data=df, x="day", y="tip", inner="quartile")
# plt.show()

```

#### ğŸ”¸ Heatmap (mapa de calor)

```{python}
# corr = df.corr(numeric_only=True)
# sns.heatmap(corr, annot=True, cmap="coolwarm")
# plt.title("Matriz de correlaciÃ³n")
# plt.show()

```

---

### ğŸ§ª Ejercicios extra

1. Usa `matplotlib` para graficar la funciÃ³n `cos(x)` en el intervalo `[0, 2Ï€]`.
2. Usa `seaborn` para mostrar un histograma de ingresos por sexo usando `df.histplot()`.
3. Crea un grÃ¡fico de barras con `plt.bar()` mostrando poblaciÃ³n por paÃ­s ficticio.
4. Con el dataset `"tips"`, grafica un `boxplot` de `"total_bill"` por `"smoker"`.
5. Genera un heatmap con la correlaciÃ³n de variables numÃ©ricas en cualquier DataFrame.

---

Este apÃ©ndice te da las herramientas bÃ¡sicas para **comunicar visualmente tus anÃ¡lisis** ğŸ“ŠğŸ§   
Â¿Te gustarÃ­a seguir con grÃ¡ficos interactivos (`plotly`, `altair`) o preparamos una lecciÃ³n de machine learning?





## ğŸ§± 21. Testing en Python

Hacer pruebas permite verificar que nuestro cÃ³digo funcione correctamente, incluso cuando lo modificamos. Python tiene herramientas como `unittest`, `pytest` y medidores de **cobertura de cÃ³digo** para mantener alta la calidad del software.

---

### ğŸ§ª Pruebas unitarias con `unittest`

Es la librerÃ­a estÃ¡ndar de testing en Python.

```{python}
# import unittest

# def sumar(a, b):
#     return a + b

# class TestOperaciones(unittest.TestCase):
#     def test_suma(self):
#         self.assertEqual(sumar(2, 3), 5)

#     def test_suma_negativa(self):
#         self.assertEqual(sumar(-1, -1), -2)

# if __name__ == "__main__":
#     unittest.main()

```

Puedes ejecutarlo desde consola:

```bash
python test_mi_modulo.py
```

---

### ğŸ§ª Pruebas con `pytest` (mÃ¡s conciso)

```bash
pip install pytest
```

Archivo `test_funciones.py`:

```{python}
# from mi_modulo import sumar

# def test_suma():
#     assert sumar(2, 2) == 4

# def test_negativos():
#     assert sumar(-1, -1) == -2

```

Desde consola:

```bash
pytest
```

âœ… `pytest` detecta automÃ¡ticamente archivos que empiecen con `test_`.

---

### ğŸ“Š Cobertura de pruebas con `coverage`

Para saber quÃ© partes del cÃ³digo han sido probadas.

```bash
pip install coverage

# Ejecutar pruebas con cobertura
coverage run -m pytest

# Generar reporte
coverage report

# Generar reporte HTML
coverage html
```

---

### âš™ï¸ AutomatizaciÃ³n de pruebas

Puedes automatizar tus pruebas:

- Con scripts de CI/CD (GitHub Actions, GitLab CI)
- Con `make`, `tox`, o scripts de `bash`
- En editores como VSCode o PyCharm con test runners integrados

---

### ğŸ§ª Ejercicios prÃ¡cticos

1. Crea una funciÃ³n `es_par(n)` y prueba que devuelve `True` para pares y `False` para impares.
2. Usa `pytest` para probar la funciÃ³n `factorial(n)`.
3. Crea pruebas para una clase `Rectangulo` con mÃ©todos `area()` y `perimetro()`.
4. Instala `coverage`, ejecuta tus pruebas y genera un reporte HTML.
5. Escribe una prueba que falle y corrÃ­gela hasta que pase.

---

Â¿Quieres un apÃ©ndice sobre pruebas parametrizadas, mocks o testing de clases en OOP? ğŸ§ªğŸ§±ğŸ§¼





---

## ğŸ“Œ ApÃ©ndice: Pruebas avanzadas â€” parametrizaciÃ³n, mocks y testing en OOP

Este apÃ©ndice cubre tÃ©cnicas Ãºtiles cuando se necesita **probar mÃºltiples casos con diferentes valores**, **simular el comportamiento de funciones externas**, o **testear clases y mÃ©todos en programaciÃ³n orientada a objetos**.

---

### ğŸ§ª Pruebas parametrizadas con `pytest.mark.parametrize`

Permite **probar una funciÃ³n con mÃºltiples entradas y salidas esperadas** sin duplicar cÃ³digo.

```{python}
# import pytest

# @pytest.mark.parametrize("a,b,esperado", [
#     (2, 3, 5),
#     (0, 0, 0),
#     (-1, 1, 0),
# ])
# def test_suma(a, b, esperado):
#     assert a + b == esperado

```

Ejecuta todos los casos automÃ¡ticamente.

---

### ğŸ­ Mocks con `unittest.mock`

Simulan funciones o mÃ©todos externos (por ejemplo, llamadas a API o consultas a base de datos).

```{python}
# from unittest.mock import patch

# def obtener_dolar():
#     # Supongamos que llama a una API externa
#     import requests
#     r = requests.get("https://api.dolar.fake")
#     return r.json()["precio"]

# @patch("requests.get")
# def test_obtener_dolar(mock_get):
#     mock_get.return_value.json.return_value = {"precio": 20.5}
#     assert obtener_dolar() == 20.5

```

âœ… Con `@patch` puedes reemplazar el comportamiento de una funciÃ³n temporalmente durante la prueba.

---

### ğŸ§± Testing en clases orientadas a objetos

```{python}
# class Rectangulo:
#     def __init__(self, base, altura):
#         self.base = base
#         self.altura = altura

#     def area(self):
#         return self.base * self.altura

# def test_area_rectangulo():
#     r = Rectangulo(4, 5)
#     assert r.area() == 20

```

Puedes usar `unittest` o `pytest` indistintamente para testear clases. Si la clase tiene muchos mÃ©todos, agrÃºpalos por funcionalidad.

---

### ğŸ§ª Ejercicios extra

1. Usa `@pytest.mark.parametrize` para testear una funciÃ³n `es_primo(n)` con varios valores.
2. Usa `unittest.mock.patch` para simular una funciÃ³n que lee un archivo sin realmente abrirlo.
3. Crea una clase `Cuenta` con mÃ©todos `depositar()` y `retirar()`, y escribe pruebas para cada uno.
4. Prueba una clase `Carro` y asegÃºrate de que `acelerar()` cambie su atributo `velocidad`.
5. Simula una API de clima con `mock` y prueba que tu funciÃ³n `consultar_clima()` maneje correctamente la respuesta.

---

Estas tÃ©cnicas te permiten testear **casos reales, externos o complejos** de forma confiable y controlada ğŸ§ªğŸ§°





## ğŸ§± 22. OptimizaciÃ³n y eficiencia en Python

En esta lecciÃ³n aprenderÃ¡s a escribir cÃ³digo mÃ¡s rÃ¡pido y con menor consumo de memoria, analizando su **complejidad**, utilizando **generadores** y herramientas de **profiling**.

---

### â±ï¸ Complejidad temporal y espacial

Se usa la notaciÃ³n **Big O** (`O(...)`) para describir el crecimiento del tiempo o espacio respecto al tamaÃ±o de entrada `n`.

| OperaciÃ³n       | Complejidad |
|------------------|-------------|
| BÃºsqueda en lista `in`  | `O(n)`       |
| BÃºsqueda en diccionario | `O(1)`       |
| Ordenamiento (`sorted`) | `O(n log n)` |
| Recorrer lista           | `O(n)`       |

#### Ejemplo de diferencia:

```{python}
# # O(n^2)
# def pares_repetidos(lista):
#     for i in lista:
#         for j in lista:
#             if i == j:
#                 pass

```

---

### ğŸ” Generadores con `yield` para eficiencia de memoria

Permiten producir valores **uno a uno**, sin almacenar toda la secuencia en memoria.

```{python}
# def cuadrados(n):
#     for i in range(n):
#         yield i**2

# for x in cuadrados(1_000_000):  # No explota la memoria
#     if x > 100:
#         break

```

âœ… Ideal para procesamiento de archivos grandes, streams o datos secuenciales.

---

### ğŸ§ª Medir tiempo con `timeit`

```{python}
# import timeit

# tiempo = timeit.timeit("sum(range(1000))", number=1000)
# print(f"Tiempo: {tiempo:.6f} segundos")

```

TambiÃ©n puedes usar como decorador con funciones:

```{python}
# @timeit.timeit
# def f():
#     return sum(range(1000))

```

---

### ğŸ” Profiling del cÃ³digo con `cProfile`

Para saber quÃ© partes de tu cÃ³digo consumen mÃ¡s tiempo:

```bash
python -m cProfile mi_script.py
```

O dentro del cÃ³digo:

```{python}
# import cProfile

# def prueba():
#     total = 0
#     for i in range(1000000):
#         total += i
#     return total

# cProfile.run("prueba()")

```

âœ”ï¸ Puedes combinarlo con herramientas como `snakeviz`, `line_profiler`, `memory_profiler` para visualizaciÃ³n avanzada.

---

## ğŸ§ª Ejercicios prÃ¡cticos

1. Escribe dos versiones de una funciÃ³n que busque un elemento: una con `for` y otra con `in`, y compÃ¡ralas con `timeit`.
2. Escribe una funciÃ³n generadora que produzca nÃºmeros pares hasta un millÃ³n sin explotar la memoria.
3. Usa `cProfile` para analizar el rendimiento de una funciÃ³n que ordene 10,000 nÃºmeros aleatorios.
4. Mide con `timeit` la diferencia entre `append()` y comprensiÃ³n de listas.
5. Implementa una funciÃ³n `factorial(n)` recursiva y analiza su comportamiento con `cProfile`.

---

Â¿Quieres que prepare un apÃ©ndice con tÃ©cnicas de vectorizaciÃ³n con `numpy`, optimizaciÃ³n con `numba` o multihilo con `concurrent.futures`?





---

## ğŸ“Œ ApÃ©ndice: OptimizaciÃ³n avanzada en Python

Cuando el rendimiento importa, Python ofrece herramientas para acelerar cÃ¡lculos intensivos, evitar bucles innecesarios y ejecutar tareas en paralelo.

---

### âš¡ VectorizaciÃ³n con `numpy`

Evita bucles usando operaciones sobre arreglos completos:

```{python}
# import numpy as np

# Lento con bucle
# lista = list(range(1000000))
# cuadrados = [x**2 for x in lista]

# RÃ¡pido con numpy
# arreglo = np.arange(1000000)
# cuadrados_np = arreglo ** 2

```

âœ… Las operaciones vectorizadas son mÃ¡s rÃ¡pidas porque se ejecutan en cÃ³digo optimizado en C.

---

### ğŸš€ CompilaciÃ³n con `numba`

`numba` traduce funciones Python a cÃ³digo mÃ¡quina usando JIT (Just-in-Time Compilation).

```bash
pip install numba
```

```{python}
# from numba import njit

# @njit
# def suma_grande(n):
#     total = 0
#     for i in range(n):
#         total += i
#     return total

# print(suma_grande(10000000))

```

âœ… Ideal para funciones numÃ©ricas puras con bucles intensivos.

---

### ğŸ§µ ParalelizaciÃ³n con `concurrent.futures`

Permite ejecutar funciones **en paralelo** (multihilo o multiproceso).

```{python}
# from concurrent.futures import ThreadPoolExecutor

# def saludar(nombre):
#     return f"Hola {nombre}"

# nombres = ["Ana", "Luis", "Carlos"]

# with ThreadPoolExecutor() as executor:
#     resultados = list(executor.map(saludar, nombres))

# print(resultados)

```

TambiÃ©n puedes usar `ProcessPoolExecutor` para tareas que consumen mucha CPU.

---

### ğŸ§ª Ejercicios extra

1. Reescribe una funciÃ³n que calcule cuadrados con `numpy` en lugar de `for`.
2. Acelera una funciÃ³n que calcule factoriales grandes usando `@njit`.
3. Usa `ThreadPoolExecutor` para aplicar una funciÃ³n a una lista de nombres en paralelo.
4. Crea una funciÃ³n que sume los elementos de una lista de 100 millones y compÃ¡rala con y sin `numba`.
5. Reescribe una simulaciÃ³n con `for` y reemplÃ¡zala por operaciones vectorizadas.

---

Estas herramientas pueden mejorar drÃ¡sticamente la velocidad de programas cientÃ­ficos, simulaciones o tareas de procesamiento masivo âš¡ğŸ§ ğŸ§µ




## ğŸ§± 23. Lectura y comprensiÃ³n de documentaciÃ³n oficial

Saber leer la documentaciÃ³n oficial es una habilidad esencial para escribir cÃ³digo limpio, entender errores, aprender nuevas herramientas y encontrar soluciones sin depender siempre de terceros.

---

### ğŸ”— Sitios oficiales clave

| Recurso                | Enlace                                                        |
|------------------------|---------------------------------------------------------------|
| DocumentaciÃ³n oficial de Python | https://docs.python.org/3/                                 |
| PyPI (paquetes externos)       | https://pypi.org                                           |
| `pandas`                      | https://pandas.pydata.org/docs/                            |
| `numpy`                       | https://numpy.org/doc/                                     |
| `matplotlib`                  | https://matplotlib.org/stable/contents.html                |
| `seaborn`                     | https://seaborn.pydata.org/                               |
| `requests`                    | https://docs.python-requests.org/en/latest/               |

---

### ğŸ“˜ CÃ³mo leer la documentaciÃ³n

1. **Inicio y descripciÃ³n del mÃ³dulo**: entender quÃ© hace y cuÃ¡ndo se usa.
2. **Ejemplos de uso**: generalmente al principio o al final de cada secciÃ³n.
3. **Definiciones de funciones/clases**:
   - Firma de la funciÃ³n (`def nombre(parÃ¡metros)`)
   - DescripciÃ³n de los parÃ¡metros (`args`, `kwargs`)
   - Valor de retorno
   - Excepciones posibles
4. **Notas y advertencias**: atenciÃ³n a cambios en versiones nuevas.
5. **Buscar con `Ctrl + F`** cuando sepas lo que necesitas.

---

### ğŸ§  Buenas prÃ¡cticas

- **Leer la firma** de la funciÃ³n antes de usarla.
- **Copiar ejemplos y probarlos** en tu propio entorno.
- Si no entiendes una funciÃ³n, **busca en Stack Overflow solo como complemento**, no como primera fuente.
- **Revisar versiones compatibles** (tu entorno puede no tener la versiÃ³n mÃ¡s reciente).

---

### ğŸ§ª Ejercicios prÃ¡cticos

1. Busca en la documentaciÃ³n oficial de Python cÃ³mo funciona `zip()` y explica quÃ© retorna.
2. Investiga en la documentaciÃ³n de `pandas` cÃ³mo usar `groupby()` y da un ejemplo simple.
3. Ve a la documentaciÃ³n de `matplotlib` y encuentra cÃ³mo cambiar el color de un grÃ¡fico de barras.
4. Lee la documentaciÃ³n de `json.dumps()` y explica quÃ© hace el parÃ¡metro `indent`.
5. En `requests`, busca cÃ³mo agregar encabezados personalizados a una solicitud `get()`.

---

### ğŸ§© Tip Ãºtil: usar `help()` y `dir()` en consola

```{python}
# import math
# help(math)
# dir(math)

```

Estos comandos te permiten explorar mÃ³dulos y funciones sin salir del intÃ©rprete.

---

Dominar la documentaciÃ³n oficial te convierte en un desarrollador mÃ¡s autÃ³nomo, rÃ¡pido y preciso ğŸ“˜ğŸ’¡





---

## ğŸ“Œ ApÃ©ndice: Docstrings, `pydoc` y documentaciÃ³n personalizada

AdemÃ¡s de leer documentaciÃ³n oficial, es importante saber **leer y escribir documentaciÃ³n propia** para tus funciones, clases y mÃ³dulos. Esto mejora la mantenibilidad y comprensiÃ³n del cÃ³digo, especialmente en equipo.

---

### ğŸ§¾ Â¿QuÃ© es un `docstring`?

Un `docstring` es un **comentario especial** al inicio de una funciÃ³n, clase o mÃ³dulo, encerrado entre triple comillas `"""`.

```{python}
# def saludar(nombre):
#     """
#     Devuelve un saludo personalizado.
#     
#     ParÃ¡metros:
#     nombre (str): Nombre de la persona.
#
#     Retorna:
#     str: Saludo.
#     """
#     return f"Hola, {nombre}"

```

âœ”ï¸ Es accesible mediante `help()`:

```{python}
# help(saludar) 
```

---

### ğŸ§° Uso de `pydoc`

`pydoc` permite generar y ver documentaciÃ³n desde la terminal.

```bash
# Ver ayuda de un mÃ³dulo
pydoc math

# Generar archivo HTML de un mÃ³dulo
pydoc -w mi_modulo
```

Esto crea una pÃ¡gina web `.html` con la documentaciÃ³n de tus funciones y clases.

---

### âœï¸ Buenas prÃ¡cticas al documentar

- Describe **quÃ© hace** la funciÃ³n, no cÃ³mo.
- Especifica:
  - ParÃ¡metros (`nombre`, tipo y descripciÃ³n)
  - Valor de retorno
  - Posibles excepciones (si aplica)
- Usa **formato consistente**: estilo Google, NumPy o reStructuredText.

---

### ğŸ“š Ejemplo estilo Google

```{python}
# def sumar(a, b):
#     """
#     Suma dos nÃºmeros.
#
#     Args:
#         a (int): Primer nÃºmero.
#         b (int): Segundo nÃºmero.
#
#     Returns:
#         int: Resultado de la suma.
#     """
#     return a + b

```

---

### ğŸ§ª Ejercicios extra

1. Escribe un `docstring` para una funciÃ³n que calcule el factorial.
2. Usa `pydoc` para inspeccionar el mÃ³dulo `collections` desde terminal.
3. Crea un archivo `.py` con varias funciones y genera su documentaciÃ³n en HTML.
4. Escribe un mÃ³dulo con funciones y documÃ©ntalas en estilo Google o NumPy.
5. Usa `help()` para explorar la documentaciÃ³n de una clase que tÃº mismo hayas definido.

---

Documentar bien tu cÃ³digo lo hace **mÃ¡s profesional, reutilizable y colaborativo** ğŸ§¾ğŸ”ğŸ“˜





---

## ğŸ“Œ ApÃ©ndice: IntroducciÃ³n a Machine Learning con `scikit-learn`

`scikit-learn` es una de las librerÃ­as mÃ¡s populares en Python para **machine learning supervisado y no supervisado**, ideal para quienes se inician en esta Ã¡rea.

---

### ğŸ§  Â¿QuÃ© es Machine Learning?

Es una rama de la inteligencia artificial que permite a los algoritmos **aprender a partir de datos**. Los dos tipos mÃ¡s comunes son:

- **Aprendizaje supervisado**: se entrena con datos etiquetados (clasificaciÃ³n, regresiÃ³n).
- **Aprendizaje no supervisado**: encuentra patrones sin etiquetas (agrupamiento, reducciÃ³n de dimensiÃ³n).

---

### ğŸ”§ Flujo tÃ­pico en `scikit-learn`

```{python}
# from sklearn.datasets import load_iris
# from sklearn.model_selection import train_test_split
# from sklearn.linear_model import LogisticRegression
# from sklearn.metrics import accuracy_score

# 1. Cargar datos
# iris = load_iris()
# X = iris.data
# y = iris.target

# 2. Dividir en conjunto de entrenamiento y prueba
# X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2)

# 3. Elegir modelo
# modelo = LogisticRegression(max_iter=1000)

# 4. Entrenar
# modelo.fit(X_train, y_train)

# 5. Evaluar
# y_pred = modelo.predict(X_test)
# print("Exactitud:", accuracy_score(y_test, y_pred))

```

---

### ğŸ§ª Modelos comunes en `scikit-learn`

| Tarea           | Modelo                            |
|-----------------|-----------------------------------|
| ClasificaciÃ³n   | `LogisticRegression`, `SVC`, `KNeighborsClassifier` |
| RegresiÃ³n       | `LinearRegression`, `Ridge`, `Lasso` |
| Agrupamiento    | `KMeans`, `DBSCAN`                |
| ReducciÃ³n de dimensiÃ³n | `PCA`, `TSNE`              |

---

### ğŸ“Š EvaluaciÃ³n de modelos

- ClasificaciÃ³n: `accuracy_score`, `confusion_matrix`, `classification_report`
- RegresiÃ³n: `mean_squared_error`, `r2_score`

```{python}
# from sklearn.metrics import classification_report

# print(classification_report(y_test, y_pred))

```

---

### ğŸ§ª Ejercicios extra

1. Carga el dataset `wine` de `sklearn.datasets` y aplica regresiÃ³n logÃ­stica.
2. Prueba un clasificador `KNeighborsClassifier` y compara su exactitud.
3. Usa `StandardScaler` para escalar tus variables antes de entrenar.
4. Aplica `KMeans` a un dataset sin etiquetas y grafica los grupos.
5. Usa `PCA` para reducir la dimensiÃ³n del dataset `iris` y grÃ¡ficalo en 2D.

---

Este apÃ©ndice es tu primer paso en el mundo del **machine learning aplicado con Python** ğŸ§ ğŸ“Š





## ğŸ§± 24. Buenas prÃ¡cticas de desarrollo en Python

Adoptar buenas prÃ¡cticas desde el inicio ayuda a escribir **cÃ³digo limpio, legible y mantenible**, lo que es esencial para proyectos colaborativos o a largo plazo.

---

### ğŸ¨ Uso de linters y formateadores

Los **linters** detectan errores y malas prÃ¡cticas.  
Los **formateadores** corrigen automÃ¡ticamente el estilo del cÃ³digo.

#### âœ… `flake8`: linter

```bash
pip install flake8

# Revisar un archivo
flake8 mi_script.py
```

Detecta errores como:
- Nombres mal escritos
- Estilo incorrecto
- CÃ³digo duplicado o innecesario

#### âœ… `black`: formateador automÃ¡tico

```bash
pip install black

# Formatear el archivo
black mi_script.py
```

Reescribe el cÃ³digo segÃºn las reglas de estilo establecidas (PEP8 y mejoras).

---

### ğŸ§± Estructura bÃ¡sica de un proyecto

```text
mi_proyecto/
â”œâ”€â”€ README.md
â”œâ”€â”€ requirements.txt
â”œâ”€â”€ .gitignore
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â””â”€â”€ mi_modulo.py
â”œâ”€â”€ tests/
â”‚   â””â”€â”€ test_mi_modulo.py
â””â”€â”€ main.py
```

- `src/`: cÃ³digo principal del proyecto
- `tests/`: pruebas automatizadas
- `requirements.txt`: dependencias
- `README.md`: descripciÃ³n del proyecto

---

### ğŸ§  Convenciones PEP8 (estilo oficial de Python)

- Usa **4 espacios por nivel de indentaciÃ³n**
- Longitud mÃ¡xima recomendada: **79 caracteres por lÃ­nea**
- **Usa snake_case** para variables y funciones
- **Usa CamelCase** para clases
- Deja **2 lÃ­neas** entre funciones o clases al nivel superior
- Usa **docstrings** para documentar funciones

```{python}
# def calcular_area(base, altura):
#     """Calcula el Ã¡rea de un rectÃ¡ngulo."""
#     return base * altura

```

---

### âœ… Otras buenas prÃ¡cticas

- Escribe funciones **cortas y especÃ­ficas**
- Evita duplicaciÃ³n de cÃ³digo
- Usa **nombres descriptivos** (no `x`, `temp`, `var`)
- Documenta con docstrings
- Usa control de versiones (`git`)
- MantÃ©n dependencias controladas (usa `venv` o `conda`)

---

## ğŸ§ª Ejercicios prÃ¡cticos

1. Instala `flake8` y revÃ­salo sobre un script con errores comunes de estilo.
2. Formatea un archivo con `black` y observa los cambios.
3. Organiza un mini proyecto con carpetas `src/` y `tests/`.
4. Reescribe una funciÃ³n con nombres poco claros (`a`, `b`) usando nombres descriptivos.
5. Escribe una funciÃ³n bien documentada que calcule el Ã¡rea de un cÃ­rculo.

---

Estas prÃ¡cticas te ayudan a escribir **cÃ³digo profesional y colaborativo desde el dÃ­a uno** ğŸ§¼ğŸ“¦âœ…

Â¿Quieres que prepare un apÃ©ndice sobre control de versiones con `git`, uso de `pre-commit`, o colaboraciÃ³n con GitHub?





---

## ğŸ“Œ ApÃ©ndice: IntegraciÃ³n continua (CI), testing automÃ¡tico y `pyproject.toml`

Cuando un proyecto crece o se trabaja en equipo, automatizar pruebas y configuraciones se vuelve clave. Este apÃ©ndice te muestra cÃ³mo configurar **testing continuo** y estructurar un proyecto moderno con `pyproject.toml`.

---

### ğŸ”„ Â¿QuÃ© es integraciÃ³n continua (CI)?

Es un proceso que **ejecuta pruebas automÃ¡ticamente** cada vez que haces cambios (por ejemplo, en GitHub). AsÃ­ puedes:

- Detectar errores rÃ¡pidamente
- Asegurar que todo sigue funcionando tras cada cambio
- Automatizar formateo, linting y pruebas

---

### ğŸ§ª Automatizar pruebas con GitHub Actions

1. Crea un archivo `.github/workflows/python-tests.yml`:

```yaml
name: Python tests

on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: "3.11"
    - name: Install dependencies
      run: |
        pip install -r requirements.txt
        pip install pytest
    - name: Run tests
      run: pytest
```

âœ”ï¸ Cada vez que subas un cambio, se ejecutarÃ¡n los tests automÃ¡ticamente.

---

### âš™ï¸ Proyecto moderno con `pyproject.toml`

Es un archivo unificado para configurar dependencias, formateadores, linters, empaquetado y mÃ¡s.

```toml
[tool.black]
line-length = 88
target-version = ["py311"]

[tool.flake8]
max-line-length = 88
exclude = ["build", "dist"]

[tool.isort]
profile = "black"
```

ğŸ“¦ Puedes usarlo para configurar:
- `black`, `flake8`, `pytest`, `mypy`
- `setuptools` o `poetry` para empaquetado
- `build`, `twine`, `coverage`, etc.

---

### ğŸ“¦ Crear `requirements.txt` o `requirements-dev.txt`

```bash
pip freeze > requirements.txt
```

O separa las dependencias de desarrollo:

```text
# requirements-dev.txt
pytest
black
flake8
coverage
```

---

## ğŸ§ª Ejercicios extra

1. Configura un archivo `pyproject.toml` con reglas para `black` y `flake8`.
2. Sube un proyecto a GitHub y activa un workflow de `pytest` con GitHub Actions.
3. AÃ±ade una regla que haga fallar el build si un test no pasa.
4. Automatiza formateo y linting en un solo paso con `pre-commit` y tu `pyproject.toml`.
5. AÃ±ade badges de estado del build en tu `README.md`.

---

Esta infraestructura te permite mantener **cÃ³digo de alta calidad de forma automÃ¡tica y escalable** ğŸš€ğŸ§ªğŸ”



---

## ğŸ“Œ ApÃ©ndice: DistribuciÃ³n de paquetes y despliegue en la nube

Este apÃ©ndice cubre cÃ³mo **empaquetar y publicar tus librerÃ­as en PyPI**, asÃ­ como ideas para **desplegar aplicaciones Python** en la nube (API, dashboards, notebooks interactivos, etc).

---

### ğŸ“¦ Publicar un paquete en PyPI

#### 1. Estructura bÃ¡sica del paquete

```text
mi_paquete/
â”œâ”€â”€ mi_paquete/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â””â”€â”€ funciones.py
â”œâ”€â”€ tests/
â”‚   â””â”€â”€ test_funciones.py
â”œâ”€â”€ README.md
â”œâ”€â”€ pyproject.toml
â””â”€â”€ LICENSE
```

#### 2. `pyproject.toml` mÃ­nimo para empaquetado

```toml
[project]
name = "mi-paquete"
version = "0.1.0"
description = "Mi primera librerÃ­a"
readme = "README.md"
requires-python = ">=3.8"
license = {text = "MIT"}
authors = [
  {name = "Tu Nombre", email = "tucorreo@example.com"}
]

[build-system]
requires = ["setuptools", "wheel"]
build-backend = "setuptools.build_meta"
```

#### 3. Empaquetar y publicar

```bash
pip install build twine

# Generar archivos
python -m build

# Subir a PyPI
python -m twine upload dist/*
```

> ğŸ‘‰ Si es la primera vez, crea cuenta en [https://pypi.org/account/register/](https://pypi.org/account/register/)

---

### â˜ï¸ Despliegue en la nube (introducciÃ³n)

Puedes **desplegar tus scripts, APIs o dashboards** en la nube fÃ¡cilmente con estas plataformas:

| Plataforma   | Ideal para               | Enlace                        |
|--------------|--------------------------|-------------------------------|
| **Render**   | APIs, backends           | https://render.com            |
| **Vercel**   | Frontend estÃ¡tico + API  | https://vercel.com            |
| **Hugging Face Spaces** | Modelos ML, notebooks | https://huggingface.co/spaces |
| **Heroku**   | Apps web simples         | https://www.heroku.com        |
| **Streamlit Cloud** | Apps de datos y ML     | https://streamlit.io/cloud     |

#### Ejemplo: subir app Streamlit a Hugging Face Spaces

```bash
# Estructura mÃ­nima
app.py
requirements.txt
```

```python
# app.py
import streamlit as st
st.title("Mi App")
st.write("Â¡Hola desde la nube!")
```

SÃºbelo a un repositorio de GitHub, luego crea un Space en Hugging Face y conÃ©ctalo. Â¡Listo!

---

## ğŸ§ª Ejercicios extra

1. Crea una funciÃ³n Ãºtil (`es_primo`, `area_triangulo`, etc.) y publÃ­cala como paquete en PyPI (puedes usar TestPyPI para practicar).
2. Prepara una app simple con `streamlit` y sÃºbela a Hugging Face Spaces.
3. Despliega una API con `Flask` en Render o Railway.
4. Explora y clona un repositorio pÃºblico en Vercel que use funciones en Python.
5. Usa `pyproject.toml` para incluir `README.md`, autor y versiÃ³n en tu primer paquete.

---

Este apÃ©ndice te abre la puerta a **compartir, desplegar y escalar tus ideas en el mundo real** ğŸš€ğŸŒğŸ“¦

